[{"title":"C++实验二","date":"2021-05-12T01:36:01.000Z","path":"2021/05/12/C-实验二/","text":"1、类基本语法练习123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Time // 定义Time类&#123;private:// 数据成员为私有的 int hour; int minute; int sec;public: // 数据成员、成员函数为公用的 void input(); void output();&#125;;void Time::input()&#123; cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; sec;&#125;void Time::output()&#123; cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; sec &lt;&lt; endl;&#125;int main()&#123; Time t1; //定义t1为Time类对象 t1.input(); //输入设定的时间 t1.output(); system(&quot;pause&quot;); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include &lt;iostream&gt;using namespace std;class Date&#123; int y, m, d;public: void init(int year, int month, int day) //判断日期是否正确 &#123; int Rm[] = &#123;1, 3, 5, 7, 8, 10, 12&#125;; int Pm[] = &#123;4, 6, 9, 11&#125;; if (!(month &gt; 12 || day &gt; 31 || (month == 2 &amp;&amp; day &gt; 29))) &#123; if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) &#123; for (int i = 0; i &lt; 7; i++) &#123; if ((month == Rm[i] &amp;&amp; day &lt;= 31) || (month == Pm[i] &amp;&amp; day &lt;= 31) || (month == 2 &amp;&amp; day &lt;= 29)) &#123; y = year; m = month; d = day; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; 7; i++) &#123; if ((month == Rm[i] &amp;&amp; day &lt;= 31) || (month == Pm[i] &amp;&amp; day &lt;= 31) || (month == 2 &amp;&amp; day &lt;= 28)) &#123; y = year; m = month; d = day; &#125; &#125; &#125; &#125; else exit(0); &#125; void print() &#123; cout &lt;&lt; y &lt;&lt; &quot; year &quot; &lt;&lt; m &lt;&lt; &quot; month &quot; &lt;&lt; d &lt;&lt; &quot; day&quot; &lt;&lt; endl; &#125; int subDate(Date d1) &#123; y -= d1.y; m -= d1.m; d -= d1.d; return (int)(y * 365 + m * 30 + d); &#125; Date addNum(int num) &#123; if ((num + d) &gt; 30) &#123; d = num + d - 30; m++; &#125; else if (m &gt; 12) &#123; y++; &#125; else d = num + d; return *this; &#125;&#125;;int main()&#123; Date d, d1, d2; int year, month, day; cout&lt;&lt;&quot;请输入日期:\\n&quot;; cin &gt;&gt; year &gt;&gt; month &gt;&gt; day; d1.init(year, month, day); d1.print(); d2.init(1998, 5, 22); cout &lt;&lt; d1.subDate(d2) &lt;&lt; &quot;天&quot; &lt;&lt; endl; d = d1.addNum(30); d.print(); system(&quot;pause&quot;); return 0;&#125; 2、运算符重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;class Point&#123; int x, y;public: void init(int a, int b) &#123; x = a; y = b; &#125; void disp() &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; &#125; Point add(Point &amp;p) &#123; Point p1; p1.x = x + p.x; p1.y = y + p.y; return p1; &#125; Point operator+(Point &amp;p) &#123; Point p1; p1.x = x + p.x; p1.y = y + p.y; return p1; &#125; friend Point operator+(const Point &amp;a, const Point &amp;b);&#125;;Point operator+(const Point &amp;a, const Point &amp;b)&#123; Point p1; p1.x = a.x + b.x; p1.y = a.y + b.y; return p1;&#125;;int main()&#123; Point a, b, c; a.init(1, 2); b.init(3, 4); c=a + b; c.disp(); system(&quot;pause&quot;); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;class Complex&#123;private: int real,image;public: Complex(); ~Complex(); void init(int r,int i); friend Complex operator-(Complex &amp;a,Complex &amp;b); friend Complex operator&lt;&lt;(ostream &amp;cout,Complex &amp;a);&#125;;Complex::Complex()&#123;&#125;Complex::~Complex()&#123;&#125;void Complex::init(int r,int i)&#123; real=r; image=i;&#125;Complex operator-(Complex &amp;a,Complex &amp;b)&#123; Complex temp; temp.real=a.real-b.real; temp.image=a.image-b.image; return temp;&#125;Complex operator&lt;&lt;(ostream &amp;cout,Complex &amp;a)&#123; cout&lt;&lt;&quot;(&quot;&lt;&lt;a.real&lt;&lt;&quot;,&quot;&lt;&lt;a.image&lt;&lt;&quot;)&quot;&lt;&lt;endl;&#125;int main()&#123; Complex c1, c2, c3; int r, i; cout &lt;&lt;&quot;\\n input first, r and i :&quot;; cin &gt;&gt; r &gt;&gt; i; c1.init(r, i); cout &lt;&lt;&quot;\\n input second, r and i :&quot;; cin &gt;&gt;r &gt;&gt; i; c2.init(r, i); c3 = c2 - c1; cout &lt;&lt; c3;system(&quot;pause&quot;); return 0;&#125; 3、构造和析构函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include&lt;iomanip&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//时间类class Time&#123; int hour;public: Time( int h) &#123; hour = h; &#125;&#125;;//日期类class Date&#123; int year; int month; int day; Time t;public: Date(int y=1900,int m=1,int d=1,int t=0):t(t) &#123; if(y&gt;12) &#123; year=y; month=m; day=d;&#125; else &#123; year=d; month=y; day=m; &#125; &#125; int getYear() &#123; return year; &#125; int getMonth() &#123; return month; &#125; int getDay() &#123; return day; &#125; friend ostream &amp; operator&lt;&lt;(ostream &amp;os,Date &amp;d); friend bool operator&lt;(Date &amp;d1,Date &amp;d2); friend bool cmpare(Date &amp;d1,Date &amp;d2);&#125;;//重载Date 的&lt; (小于)运算符, 比较日期. 自己定义比较规则bool operator&lt;(Date &amp;d1,Date &amp;d2)&#123; if(d1.year!=d2.year) return d1.year&lt;d2.year; else if(d1.month!=d2.month) return d1.month&lt;d2.month; else if(d1.day!=d2.day) return d1.day&lt;d2.day; else return false;&#125;//比较大小bool cmpare(Date &amp;d1,Date &amp;d2)&#123; if(d1.year!=d2.year) return d1.year&gt;d2.year; else if(d1.month!=d2.month) return d1.month&gt;d2.month; else if(d1.day!=d2.day) return d1.day&gt;d2.day; else return false;&#125;//重载&lt;&lt;ostream &amp; operator&lt;&lt;(ostream &amp;os,Date &amp;d)&#123; os&lt;&lt;d.year&lt;&lt;&quot;-&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;d.month&lt;&lt;&quot;-&quot;&lt;&lt;setw(2)&lt;&lt;d.day&lt;&lt;endl; return os;&#125;int main()&#123; //初始化日期 Date a(1990,1,1), b(3,5,1990),c; cout&lt;&lt;a&lt;&lt;b&lt;&lt;c; //从键盘读入若干个日期, 放入到数组或向量vector中，用对日期排序输出 vector &lt;Date&gt; v1; v1.push_back(Date(1935,2,5)); v1.push_back(Date(1933,2,5)); v1.push_back(Date(1978,2,5)); v1.push_back(Date(1978,3,5)); v1.push_back(Date(1978,5,15)); v1.push_back(Date(1978,5,5)); v1.push_back(Date(1932,2,5)); v1.push_back(Date(2000,3,5)); v1.push_back(Date(1911,5,15)); v1.push_back(Date(2021,5,5)); cout&lt;&lt;&quot;排序前&quot;&lt;&lt;endl; for(vector &lt;Date&gt;::iterator it=v1.begin();it&lt;v1.end();it++) &#123; cout&lt;&lt;it-&gt;getYear()&lt;&lt;&quot;-&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;it-&gt;getMonth()&lt;&lt;&quot;-&quot;&lt;&lt;setw(2)&lt;&lt;it-&gt;getDay()&lt;&lt;endl; &#125; cout&lt;&lt;&quot;排序后&quot;&lt;&lt;endl; sort(v1.begin(),v1.end(),cmpare); for(vector &lt;Date&gt;::iterator it=v1.begin();it&lt;v1.end();it++) &#123; cout&lt;&lt;it-&gt;getYear()&lt;&lt;&quot;-&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;it-&gt;getMonth()&lt;&lt;&quot;-&quot;&lt;&lt;setw(2)&lt;&lt;it-&gt;getDay()&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; I/O流和文件操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;bool prime(int x)&#123; if (x &lt;= 1) return false; if (x == 2) return true; // int j=int(sqrt(x)); for (int i = 2; i &lt; x; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125;int main()&#123; int i = 0; cout&lt;&lt;&quot;请输入五个数字:&quot;&lt;&lt;endl; ofstream in(&quot;data.dat&quot;); while (i &lt; 5) &#123; int a; cin &gt;&gt; a; in &lt;&lt; a &lt;&lt; &quot; &quot;; i++; &#125; in.close(); int a[5]; ifstream out(&quot;data.dat&quot;); if (!out.is_open()) &#123; cout &lt;&lt; &quot;error opening file&quot;; exit(1); &#125; for (int i = 0; i &lt; 5; i++) &#123; out &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; 5; i++) &#123; if (prime((int)a[i])) cout &lt;&lt; a[i] &lt;&lt; endl; &#125; out.close(); system(&quot;pause&quot;); return 0;&#125; 5、自己编写程序一、下面是一个计算器类的定义，请完成该类成员函数的实现。二、根据注释语句的提示，实现类Date的成员函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;class Counter&#123;private: int value;public: Counter(int number)&#123; value=number;&#125; void increment() //给原值加1 &#123; value+=1; &#125; void decrement() //给原值减1 &#123; value-=1; &#125; int getValue() //取得计数器值 &#123; return value; &#125; void print() //显示计数 &#123; cout&lt;&lt;value&lt;&lt;endl; &#125;&#125;;class Date&#123;public: void printDate()//显示日期 &#123; cout&lt;&lt;year&lt;&lt;&quot; years &quot;&lt;&lt;month&lt;&lt;&quot; month &quot;&lt;&lt;day&lt;&lt;&quot; day &quot;&lt;&lt;endl; &#125; void setDay(int d)//设置日的值 &#123; day=d; &#125; void setMonth(int m)//设置月的值 &#123; month=m; &#125; void setYear(int y)//设置年的值 &#123; year=y; &#125;private: int day,month,year;&#125;;int main()&#123; //计算器 Counter a(10),b(8); a.print(); a.increment(); cout&lt;&lt;&quot;加1:&quot;&lt;&lt;a.getValue()&lt;&lt;endl; b.print(); b.decrement(); cout&lt;&lt;&quot;减1:&quot;&lt;&lt;b.getValue()&lt;&lt;endl; //时间类 Date testDay; testDay.setDay(5); testDay.setMonth(10); testDay.setYear(2014); testDay.printDate(); system(&quot;pause&quot;); return 0;&#125; 三、建立一个源程序文件，在此文件中建立一个新的类，将新建的类命名为Rect。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;using namespace std;class Rect&#123;public: int Area_int() &#123; return nLength * nWidth; &#125; double Area_double() &#123; return dLength * dWidth; &#125; Rect(double length, double width) &#123; dLength = length; dWidth = width; cout &lt;&lt; &quot;I am the constructor!&quot; &lt;&lt; endl; &#125; Rect(int length, int width) &#123; nLength = length; nWidth = width; &#125; virtual ~Rect() &#123; cout &lt;&lt; &quot;I am the destructor&quot; &lt;&lt; endl; &#125;private: int nLength; int nWidth; double dLength; double dWidth;&#125;;int main()&#123; Rect r1(5, 10); Rect r2(3.0, 2.0); Rect *r3 = new Rect(3.0, 2.0); Rect *r4 = new Rect(2, 5); cout &lt;&lt; &quot;r1Area_int:&quot; &lt;&lt; r1.Area_int() &lt;&lt; endl; cout &lt;&lt; &quot;r2Area_double:&quot; &lt;&lt; r2.Area_double() &lt;&lt; endl; cout &lt;&lt; &quot;r3Area_double:&quot; &lt;&lt; r3-&gt;Area_double() &lt;&lt; endl; cout &lt;&lt; &quot;r4Area_int:&quot; &lt;&lt; r4-&gt;Area_int() &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 四、声明一个Student类，在该类中包括一个数据成员score（分数）、两个静态数据成员total_score（总分）和count(学生人数)；还包括一个成员函数account()用于设置分数、累计学生的成绩之和、累计学生人数，一个静态成员函数sum()用于返回学生的成绩之和，另一个静态成员函数average()用于求全班成绩的平均值。在main()函数中，输入某班学生的成绩，并调用上述函数求出全班学生的成绩之和和平均分。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;class Student&#123;private: int score;public: static float total_score; static int count; Student() &#123;&#125; void account(float s); static float sum(); static float average();&#125;;int Student::count = 0;float Student::total_score = 0;void Student::account(float s)&#123; count++; total_score += s; score = s;&#125;float Student::sum()&#123; return total_score;&#125;float Student::average()&#123; return total_score / count;&#125;int main()&#123; Student s1, s2, s3; s1.account(90.5); s2.account(93.5); s3.account(97); cout &lt;&lt; &quot;全班学生总分:&quot; &lt;&lt; setprecision(5) &lt;&lt; Student::sum() &lt;&lt; endl; cout &lt;&lt; &quot;全班学生平均分:&quot; &lt;&lt; setprecision(4) &lt;&lt; Student::average() &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 五、依据下面的描述设计并实现一个时间类Time，并在main函数中定义所需要的对象验证所实现代码的正确性。 私有数据成员包含小时（Hour）、分钟（Minute）和秒（Second）； 三个重载构造函数： 一个是无参数的构造函数； 一个是带参数的构造函数，实现对数据成员的初始化； 一个是copy构造函数，实现用一个对象初始化本对象； 成员函数实现时间对象相加、减运算： Time Add(Time&amp;); Time Sub(Time&amp;); 友元函数实现时间对象相加、减的运算符重载： friend Time operator + (Time&amp;， Time&amp;)； friend Time operator − (Time&amp;， Time&amp;)； 公有成员函数void Display（）；输出对象的数据成员； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;using namespace std;class Time&#123;private: int Hour, Minute, Second;public: Time() &#123;&#125; Time(int h, int m, int s); Time(const Time &amp;obj); Time Add(Time &amp;a) &#123; int x, y, z; x = Hour + a.getHour(); y = Minute + a.getMinute(); z = Second + a.getSecond(); if (z &gt;= 60) &#123; // z%=60; y += z %= 60; &#125; if (y &gt;= 60) &#123; int a = y / 60; y %= 60; x += a; &#125; Time temp(x, y, z); return temp; &#125; Time Sub(Time &amp;a) &#123; int x, y, z; x = Hour - a.getHour(); y = Minute - a.getMinute(); z = Second - a.getSecond(); if (z &lt; 0) &#123; z = 60 + z; y -= 1; &#125; if (y &lt; 0) &#123; y += 60; x -= 1; &#125; Time temp(x, y, z); return temp; &#125; friend Time operator+(Time &amp;a, Time &amp;b); friend Time operator-(Time &amp;a, Time &amp;b); void Display() &#123; cout &lt;&lt; Hour &lt;&lt; &quot;时&quot; &lt;&lt; Minute &lt;&lt; &quot;分&quot; &lt;&lt; Second &lt;&lt; &quot;秒&quot; &lt;&lt; endl; &#125; int getHour() &#123; return Hour; &#125; int getMinute() &#123; return Minute; &#125; int getSecond() &#123; return Second; &#125;&#125;;Time::Time(int h, int m, int s)&#123; Hour = h; Minute = m; Second = s;&#125;Time::Time(const Time &amp;obj)&#123; Hour = obj.Hour; Minute = obj.Minute; Second = obj.Second;&#125;Time operator+(Time &amp;a, Time &amp;b)&#123; return a.Add(b);&#125;Time operator-(Time &amp;a, Time &amp;b)&#123; return a.Sub(b);&#125;int main()&#123; cout &lt;&lt; &quot;请输入日期:\\n&quot;; int x[2], y[2], z[2], i = 0; while (i &lt; 2) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; z[i]; if (x[i] &gt; 24 || x[i] &gt; 60 || z[i] &gt; 60) exit(0); i++; &#125; Time t1(x[0], y[0], z[0]); Time t2(x[1], y[1], z[1]), t3, t4, t5, t6; t3 = t1.Add(t2); t4 = t1.Sub(t2); t5 = t1 + t2; t6 = t1 - t2; cout &lt;&lt; &quot; 成员函数实现时间对象相加、减运算：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;t3=t1.Add(t2)=&quot;; t3.Display(); cout &lt;&lt; &quot;t4=t1.sub(t2)=&quot;; t4.Display(); cout &lt;&lt; &quot;友元函数实现时间对象相加、减的运算符重载：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;t5=t1+t2=&quot;; t5.Display(); cout &lt;&lt; &quot;t6=t1-t2=&quot;; t6.Display(); system(&quot;pause&quot;); return 0;&#125;","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://luikui.xyz/tags/C/"}]},{"title":"进程控制","date":"2021-05-06T12:29:48.000Z","path":"2021/05/06/进程控制/","text":"操作系统实验 一 进程的控制环境：VMware+Ubuntu20.4+Visual Studio Code(Linux)注意：unistd.h 是 C 和 C++ 程序设计语言中提供对 POSIX 操作系统 API 的访问功能的头文件的名称，也就是Unix，包括 Mac OS X、Linux 等，所以最好用liunx环境 ※※※※以下所有运行结果都不唯一※※※※fork()函数1234567891011121314151617#include &quot;stdio.h&quot;#include &quot;unistd.h&quot; //unix 标准头文件，fork函数等的定义在这里int main()&#123; int p = fork(); // 创建进程 if (p == 0) &#123; printf(&quot;child:%d\\n&quot;, getpid()); //输出当前进程的pid，即子进程的pid &#125; else &#123; printf(&quot;parent:%d\\n&quot;, getpid()); //输出父进程的pid printf(&quot;hello world\\n&quot;); &#125; return 0;&#125; 运行结果: 提示：1. exit(int 错误代码): exit(0)：表示无错误，作用：无条件退出进程，使用头文件： stdlib.h2. Wait的用法 waitpid：pid_t waitpid(pid_t pid,int * status,int options); 等待指定的子进程结束3. exec函数的用法1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;sys/types.h&gt;int main(int argc, char *argv[])&#123; int pid; if ((pid = fork()) == 0) &#123; execlp(&quot;ls&quot;, &quot;&quot;, &quot;-l&quot;, NULL); printf(&quot;exec error&quot;); &#125; else &#123; wait(&amp;pid); waitpid(pid, NULL, -1); //等待子进程结束 printf(&quot;parent process\\n&quot;); &#125;&#125; 实验目的通过进程的创建、撤消和运行加深对进程概念和进程并发执行的理解,明确进程与程序之间的区别。实验内容1. 了解系统调用fork()、exec()、exit()和waitpid()的功能和实现过程。自行百度！！！2. 编写一段程序，使用系统调用fork()来创建两个子进程，并由父进程重复显示字符串“parent:”和自己的进程号，子进程则重复显示字符串”child： ”和自己的进程号。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; int p1, p2; p1 = fork(); if (p1 &lt; 0) &#123; printf(&quot;创建子进程失败！&quot;); &#125; else if (p1 == 0) &#123; //p1子进程 while (1) &#123; printf(&quot;child:%d\\n&quot;, getpid()); //输出当前进程的pid，即子进程的pid &#125; &#125; else &#123; //p1父进程 p2 = fork(); if (p1 &lt; 0) &#123; printf(&quot;创建子进程失败！&quot;); &#125; else if (p2 == 0) &#123; while (1) &#123; printf(&quot;child:%d\\n&quot;, getpid()); //输出父进程的pid &#125; &#125; else &#123; //p2父进程 while (1) &#123; printf(&quot;parent:%d\\n&quot;, getpid()); //输出当前进程的pid，即子进程的pid &#125; &#125; return 0; &#125; 运行结果: 3.编写一段程序，使用系统调用fork()来创建一个子进程。子进程通过系统调用exec()更换自己的执行代码，新的代码显示“ new program.”后，调用exit()结束。父进程则调用Waitpid()等待子进程结束，并在子进程结束后，显示子进程的标识符然后正常结束.Exec函数的用法实例可以参考网络课程中的视频教程123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;int main(int argc,char *argv[])&#123; int pid; pid=fork(); if(pid&lt;0)&#123; printf(&quot;创建子进程失败&quot;); &#125;else if(pid==0)&#123; if(execlp(&quot;/home/ubuntu/OperationSystem/实验一/program&quot;,&quot;&quot;,NULL)&lt;0)&#123; //更换执行代码 printf(&quot;exec error\\n&quot;); exit(1); //异常结束 &#125; exit(0);//子进程正常结束 &#125; else&#123; printf(&quot;child pid:%d\\n&quot;,waitpid(pid,NULL,WUNTRACED)); //等待子进程结束，返回子进程pid exit(0); //父进程正常结束 &#125; return 0;&#125; program.cpp(程序路径由你的路径决定)123456#include&lt;stdio.h&gt;int main(int argc,char *argv[])&#123; printf(&quot;new program.\\n&quot;); return 0;&#125; 运行结果: 4. 设计多进程，通过实验得出结果：父子进程能不能共享局部变量，共享全局变量？（即在一个进程中是否能修改另一个进程的数据），并用学过的相关进程知识解释12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/wait.h&gt;int a=10; //全局变量int main()&#123; pid_t pid; int b=20; //局部变量 pid=fork(); //创建进程。扩展：vfork()创建的子进程共享父进程的地址空间 if(pid&lt;0)&#123; printf(&quot;fork error &quot;); &#125; else if(pid==0)&#123; a=100; //子进程修改全局变量 b=200; //子进程修改局部变量 printf(&quot;child:a=%d,b=%d\\n&quot;,a,b); exit(0); &#125; else&#123; //父进程 waitpid(pid,NULL,WUNTRACED); printf(&quot;father:a=%d,b=%d\\n&quot;,a,b); &#125; return 0;&#125; 运行结果: 当我把前三个题做了之后，我突然找到老师实验来源！！！！ 后面的题看下面链接！！！！链接：https://blog.csdn.net/demo_yo/article/details/1067259863.思考 系统调用fork()是如何创建进程的？ 当首次将CPU调度给子进程时，其入口在哪里？ 系统调用exec()是如何更换进程的可执行代码的？ 系统调用exit()是如何终止一个进程的？ 对一个应用，如果用多个进程的并发执行来实现，与单个进程来实现有什么不同？","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"},{"name":"C语言","slug":"C语言","permalink":"https://luikui.xyz/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://luikui.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"回溯法01背包-考试","date":"2021-04-19T16:14:06.000Z","path":"2021/04/20/回溯法01背包-考试/","text":"回溯法01背包※※※※只为考试，解释大致意思，如有错误还望海涵！※※※※有载重量的背包，物体重量分别为5,15,25,27,30，物体价值分别为12,30,44,46,50。求最优装入背包的物体及价值。 为0，计算，大于，生成结点1,2,3,4，部分解(1,1,1,0)； 在结点4计算，大于，继续向下搜索生成结点5，得到价值为86的可行解(1,1,1,0,0)，保存在解向量中， 更新为86； 由叶结点5继续搜索时，被置为86，不大于的值，因此，沿右儿子分支结点回溯到左儿子分支结点3，生成右儿子分支结点6，得到部分解(1,1,0)； 在结点6计算，大于，因此，生成结点7,8,，得到价值为87的可行解(1,1,0,1,0)，更新解向量，更新为87； 由叶结点8继续搜索时，被置为87，不大于的值，因此，沿右儿子分支结点回溯到左儿子分支结点7，生成右儿子分支结点9，得到部分解(1,1,0,0)； 在结点9计算，大于，生成结点10，得到价值为92的可行解(1,1,0,0,1)，更新解向量，更新为92； 由叶结点10继续搜索时，被置为92，不大于的值，因此，进行回溯，因为结点10是左儿子结点，生成右儿子结点11，得到可行解(1,1,0,0,0)； 由叶结点11继续搜索时，被置为42，不大于的值，因此，沿右儿子分支结点回溯到左儿子分支结点2，生成右儿子分支结点12，得到部分解(1,0)； 在结点12计算，小于，因此，回溯到左儿子分支结点1，生成右儿子分支结点13，得到部分解(0)； 在结点13计算，小于，因此，向上回溯到根结点0，结束算法。最后，由向量中的内容，得到最优解(1,1,0,0,1)，从中得到最大价值92。 白话开始，请配合书、PPT和word食用更佳！！！！！※※※※注意左下角是计算p_est,不是计算p_total※※※※","link":"","tags":[{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"有向图-考试","date":"2021-04-19T15:13:12.000Z","path":"2021/04/19/有向图-考试/","text":"6.2.1 多段图的决策过程※※※※只为考试，解释大致意思，如有错误还望海涵！※※※※多段图的最短路径问题，是求从源点到达收点的最小花费的通路。 数组元素cost[i]：存放顶点i到达收点t的最小花费数组元素path[i]：存放顶点i到达收点t的最小花费通路上的前方顶点编号数组route[n]：存放从源点s出发，到达收点t的最短通路上的顶点编号 白话开始，请配合书、PPT和word食用更佳！！！！！","link":"","tags":[{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++实验一","date":"2021-04-17T16:54:30.000Z","path":"2021/04/18/C++实验一/","text":"2、结构化程序设计基础123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int main()&#123; int n; int a[9000]; //确保保存最终运算的数组足够大 int digit = 1; //位数 int temp; //阶乘的任意元素与临界结果的某位的乘机结果 int i, j, carry; cout &lt;&lt; &quot;input a num:&quot; &lt;&lt; endl; cin &gt;&gt; n; a[0] = 1; for (i = 2; i &lt;= n; i++) // &#123; for (j = 1, carry = 0; j &lt;= digit; j++) &#123; temp = a[j - 1] * i + carry; a[j - 1] = temp % 10; carry = temp / 10; &#125; while (carry) &#123; a[++digit - 1] = carry % 10; carry = carry / 10; &#125; &#125; cout &lt;&lt; n &lt;&lt; &quot;!=&quot;; for (j = digit; j &gt;= 1; j--) &#123; cout &lt;&lt; a[j - 1]; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 3、引用和函数1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;void swap(int &amp;a, int &amp;b)&#123; int t; t = a; a = b; b = t;&#125;int main()&#123; int a = 1, b = 6; cout &lt;&lt; &quot;before swap:\\n&quot; &lt;&lt; &quot;a is:&quot; &lt;&lt; a &lt;&lt; &quot; b is:&quot; &lt;&lt; b &lt;&lt; endl; swap(a, b); cout &lt;&lt; &quot;after swap:\\n&quot; &lt;&lt; &quot;a is:&quot; &lt;&lt; a &lt;&lt; &quot; b is:&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 4、函数的重载和默认参数12#include &lt;iostream&gt;using namespace std; 第一个方法最简单，第二个比较笨，第三个很难！第一种方法1234567891011121314151617181920212223242526//第一种方法void print(float year, char sex)&#123; cout &lt;&lt; (int)(year + 0.5) &lt;&lt; &quot;years old,&quot; &lt;&lt; ((sex == &#x27;M&#x27; || sex == &#x27;m&#x27;) ? &quot;male&quot; : &quot;female&quot;) &lt;&lt; endl;&#125;void print(char sex, float year)&#123; cout &lt;&lt; (int)(year + 0.5) &lt;&lt; &quot;years old,&quot; &lt;&lt; ((sex == &#x27;M&#x27; || sex == &#x27;m&#x27;) ? &quot;male&quot; : &quot;female&quot;) &lt;&lt; endl;&#125;void print()&#123; cout &lt;&lt; &quot;0 years old,male&quot; &lt;&lt; endl;&#125;int main()&#123; float year; char sex; cout &lt;&lt; &quot;请输入年龄和性别:&quot; &lt;&lt; endl; cin &gt;&gt; year &gt;&gt; sex; print(year, sex); print(sex, year); print(); //这里输出0 years old， male，即默认是0岁，male system(&quot;pause&quot;); return 0;&#125; 第二种方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void print(float year, char sex)&#123; if (sex == &#x27;M&#x27; || sex == &#x27;m&#x27;) &#123; int a = year * 10; if (a % 10 &gt;= 5) &#123; cout &lt;&lt; a / 10 + 1 &lt;&lt; &quot; years old,male&quot; &lt;&lt; endl; &#125; else if (a % 10 &lt; 5) &#123; cout &lt;&lt; a / 10 &lt;&lt; &quot; years old,male&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; &quot; years old,male&quot;; &#125; &#125; else &#123; int a = year * 10; if (a % 10 &gt;= 5) &#123; cout &lt;&lt; a / 10 + 1 &lt;&lt; &quot; years old,female&quot; &lt;&lt; endl; &#125; else if (a % 10 &lt; 5) &#123; cout &lt;&lt; a / 10 &lt;&lt; &quot; years old,female&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; &quot; years old,male&quot;; &#125; &#125;&#125;void print(char sex, float year)&#123; if (sex == &#x27;M&#x27; || sex == &#x27;m&#x27;) &#123; int a = year * 10; if (a % 10 &gt;= 5) &#123; cout &lt;&lt; a / 10 + 1 &lt;&lt; &quot; years old,male&quot; &lt;&lt; endl; &#125; else if (a % 10 &lt; 5) &#123; cout &lt;&lt; a / 10 &lt;&lt; &quot; years old,male&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; &quot; years old,male&quot;; &#125; &#125; else &#123; int a = year * 10; if (a % 10 &gt;= 5) &#123; cout &lt;&lt; a / 10 + 1 &lt;&lt; &quot; years old,female&quot; &lt;&lt; endl; &#125; else if (a % 10 &lt; 5) &#123; cout &lt;&lt; a / 10 &lt;&lt; &quot; years old,female&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; &quot; years old,male&quot;; &#125; &#125;&#125;void print()&#123; cout &lt;&lt; &quot;0 years old,male&quot; &lt;&lt; endl;&#125;int main()&#123; float year; char sex; cout &lt;&lt; &quot;请输入年龄和性别:&quot; &lt;&lt; endl; cin &gt;&gt; year &gt;&gt; sex; print(year, sex); print(sex, year); print(); //这里输出0 years old， male，即默认是0岁，male system(&quot;pause&quot;); return 0;&#125; 第三种方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//用char数组解决//这里输出years和sex顺序不同，但方法体是相同的。void print(float year, char sex)&#123; int y = 0; y = (int)year; if (sex == &#x27;M&#x27; || sex == &#x27;m&#x27;) &#123; cout &lt;&lt; year &lt;&lt; &quot;years old,male&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; year &lt;&lt; &quot;years old,female&quot; &lt;&lt; endl; &#125;&#125;//出参数顺序不同意外，其它都是相同的。void print(char sex, float year)&#123; int y = 0; y = (int)year; if (sex == &#x27;M&#x27; || sex == &#x27;m&#x27;) &#123; cout &lt;&lt; year &lt;&lt; &quot;years old,male&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; year &lt;&lt; &quot;years old,female&quot; &lt;&lt; endl; &#125;&#125;//这里输出0 years old,male，即默认是0岁,malevoid print()&#123; cout &lt;&lt; &quot;0 years old,male&quot; &lt;&lt; endl;&#125;int main()&#123; float year; char sex; char input[20]; char years[20]; char dot[20]; char *p; p = dot; cout &lt;&lt; &quot;请输入年龄和性别:&quot; &lt;&lt; endl; cin &gt;&gt; input; //输入字符串 //字符串数组最后一位一定是性别，首先提取出来存放在sex变量中。 sex = input[strlen(input) - 1]; //将输入数组除最后一个字符以外的字符串传入年龄数组。 for (int i = 0; i &lt; strlen(input) - 1; i++) &#123; years[i] = input[i]; &#125; for (int j = 0; j &lt; strlen(years); j++) &#123; if (years[j] == &#x27;.&#x27;) &#123; *p = years[j + 1]; &#125; &#125; //判断，若atoi(p)大于5，则年龄整体+1，若小于5，则年龄整体不变。 if (atoi(p) &gt;= 5) year = (float)(atoi(years) + 1); else year = (float)atoi(years); ///调用print函数。Pring函数要进行重载。 print(year, sex); print(sex, year); print(); //这里输出0 years old， male，即默认是0岁，male system(&quot;pause&quot;); return 0;&#125; 5、自己编写程序（1）从键盘上读入两数，比较两个数的大小，并按从小到大的次序输出。（要求使用变量引用）123456789101112131415161718192021222324252627282930#include &lt;iostream&gt; //预操作#include &lt;cmath&gt;using namespace std; // 使用命名空间stdvoid min(int &amp;c, int &amp;d)&#123; if (c &gt; d) &#123; cout &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; &#125; else if (c &lt; d) &#123; cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl; &#125; if (c == d) &#123; cout &lt;&lt; &quot;The two numbers are equal&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; int a, b; cout &lt;&lt; &quot;Please printf two numbers:&quot; &lt;&lt; endl; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; &quot;Two numbers from small to large order is:&quot; &lt;&lt; &quot; &quot;; min(a, b); system(&quot;pause&quot;); return 0;&#125; （2） 输出1到1000的素数，一行5个。两种方法差不多，只是时间复杂度一样，只是第二种比第一种执行次数少一些12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//第一种方法#include &lt;iostream&gt;using namespace std;int main()&#123; int n = 0; for (int i = 0; i &lt;= 1000; i++) &#123; if (2 == i || 3 == i) &#123; cout&lt;&lt;i&lt;&lt;&quot;\\t&quot;; n++; &#125; for (int j = 2; j &lt;= i / 2; j++) &#123; if (0 == i % j) break; if (i / 2 == j) &#123; cout&lt;&lt;i&lt;&lt;&quot;\\t&quot;; n++; &#125; if (5 == n) &#123; n = 0; cout&lt;&lt;&quot;\\n&quot;; &#125; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;// 第二种方法#include &lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n = 0; for (int i = 2; i &lt;= 1000; i++) &#123;bool isPrime = true; for (int j = 2; j &lt;= pow(i,0.5); j++) &#123; if ( i % j == 0)&#123; isPrime = false; break;&#125; &#125; if(isPrime)&#123; if (5 == n) &#123; n = 0; cout&lt;&lt;&quot;\\n&quot;;; &#125; cout&lt;&lt;i&lt;&lt;&quot;\\t&quot;; n++; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; （3）编写一个C++风格的程序，解决百元问题：将一元人民币兑换成1、2、5分的硬币，有多少种换法？可以降低到O(n²)和O(n)(已经降到)1234567891011121314151617181920212223242526272829303132//O(n²)#include &lt;iostream&gt;using namespace std;int main()&#123; int n = 0; for (int j = 0; j &lt;= 50; j++) for (int k = 0; k &lt;= 20; k++) &#123; int s = 2 * j + 5 * k; if (s &lt;= 100) n++; &#125; cout &lt;&lt; n &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;//O(n)#include &lt;iostream&gt;using namespace std;int main()&#123; int n = 0; for (int i = 0; i &lt;= 20; i++) &#123;//i表示5分的银币 n += ((100 - i*5) / 2)+1; &#125; cout &lt;&lt; n &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; （4）编写一个程序，建立一个上sroot（）的函数，返回其参数的二次方根。要求使用重载函数，重载3次，让其返回整数、长整数与双精度数的二次方根。1234567891011121314151617181920212223242526#include&lt;iostream&gt; #include&lt;cmath&gt;using namespace std;double sroot(int a)&#123; return sqrt(a);&#125;double sroot(long b)&#123; return sqrt(b);&#125;double sroot(double c)&#123; return sqrt(c);&#125;int main()&#123; int a = 5; long b = 1234; double c = 10.99;cout &lt;&lt; a &lt;&lt; &quot;的二次方根为&quot; &lt;&lt; sroot(a) &lt;&lt; endl;//此时调用的是参数为int型的sroot cout &lt;&lt; b &lt;&lt; &quot;的二次方根为&quot; &lt;&lt; sroot(b) &lt;&lt; endl;//此时调用的是参数为long型的sroot cout &lt;&lt; c &lt;&lt; &quot;的二次方根为&quot; &lt;&lt; sroot(c) &lt;&lt; endl;//此时调用的是参数为double型的sroot system(&quot;pause&quot;); return 0;&#125;0 （5）写C++风格的程序，用二分法求解f（x）=0的根。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;/*@to do:获取自变量x的函数值@param x:自变量x*/float getBinarySearchFuntion(float x) &#123; return x * x - 3*x + 2.0f;&#125;/*@to do:获取误区范围小于e的获取区间[a,b]的根@param a:开始查找的下限@param b:开始查找的上限@param e:精确度，便于跳出循环*/float getSearchAnser(float a,float b,float e) &#123; if (getBinarySearchFuntion(a)*getBinarySearchFuntion(b)&gt;0) &#123; //查找算法失效 return 0.0f ; &#125; while (true) &#123; //计算中间值 float x = 0.5f*(a + b); //获取函数值的绝对值 float f = abs(getBinarySearchFuntion(x)); float tol = abs(b - a); //判断是否跳出循环 if (f &lt; e || tol &lt; e) &#123; return x; &#125; //开始折半搜索查找 if (getBinarySearchFuntion(x)*getBinarySearchFuntion(a) &lt; 0) &#123; b = x; &#125; else &#123; a = x; &#125; &#125; &#125;int main()&#123; //测试数据 float a = 1.1f; float b = 3.0f; float e = 1e-8; float x= getSearchAnser(a, b, e); cout &lt;&lt; &quot;函数为X^2 - 3X + 2在区间[&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;]&quot; &lt;&lt; &quot;上的根为：&quot; &lt;&lt; x &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; （6）编写一个程序，用动态分配空间的方法计算 Fibonacci数列的前20项并存储到动态分配的空间中。注：使用malloc和free来实现12345678910111213141516171819202122232425262728293031323334353637383940//使用new和delete来实现#include&lt;iostream&gt;using namespace std;int main() &#123; int* p = new int[20]; *p = 0;//第一个为0 *(p + 1) = 1;//第二个为1 for (int i = 2; i &lt; 20; ++i) &#123; *(p + i) = *(p + i - 1) + *(p + i - 2); &#125; for (int i = 0; i &lt; 20; ++i) &#123; cout &lt;&lt; *(p + i)&lt;&lt;&quot;\\t&quot;; &#125; cout &lt;&lt; endl; delete p; system(&quot;pause&quot;); return 0;&#125;//使用malloc和free来实现#include&lt;iostream&gt;using namespace std;int main()&#123; int *p = (int *)malloc(sizeof(int) * 20); *p = 0; //第一个为0 *(p + 1) = 1; //第二个为1 for (int i = 2; i &lt; 20; ++i) &#123; *(p + i) = *(p + i - 1) + *(p + i - 2); &#125; for (int i = 0; i &lt; 20; ++i) &#123; cout &lt;&lt; *(p + i) &lt;&lt; &quot;\\t&quot;; &#125; free(p); cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://luikui.xyz/tags/C/"}]},{"title":"分支界限法","date":"2021-04-12T14:44:07.000Z","path":"2021/04/12/分支界限法/","text":"利用分支界限法求解旅行售货员问题某售货员要到若干城市去推销商品，已知各城市之间的路程（旅费），他要选定一条从驻地出发，经过每个城市一遍，最后回到驻地的路线，使总的路程（总旅费）最小。 求解思想：旅行售货员问题的解空间可以组织成一棵树，从树的根结点到任一叶结点的路径定义了图的一条周游路线。旅行售货员问题要在图 G 中找出费用最小的周游路线。路线是一个带权图。图中各边的费用（权）为正数。图的一条周游路线是包括 V 中的每个顶点在内的一条回路。周游路线的费用是这条路线上所有边的费用之和。LvXingShouhuoyuan类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class LvXingShouhuoyuan &#123; float[][] a;//图G的邻接矩阵 public LvXingShouhuoyuan(float[][] a) &#123; this.a = a; &#125; public static class HeapNode implements Comparable &#123; float lcost;//子树费用的下界 float cc;//当前费用 float rcost;//x[s:n-1]中顶点最小出边费用和 int s;//根节点到当前节点的路径为x[0:s] int[] x;//需要进一步搜索的顶点是x[s+1:n-1] //构造方法 public HeapNode(float lc, float ccc, float rc, int ss, int[] xx) &#123; lcost = lc; cc = ccc; s = ss; x = xx; &#125; public int compareTo(Object x) &#123; float xlc = ((HeapNode) x).lcost; if (lcost &lt; xlc) return -1; if (lcost == xlc) return 0; return 1; &#125; &#125; public float bbTsp(int[] v) &#123; int n = v.length - 1;//节点数 LinkedList&lt;HeapNode&gt; heap = new LinkedList&lt;HeapNode&gt;(); //minOut[i]=i的最小出边费用 float[] minOut = new float[n + 1]; float minSum = 0;//最小出边费用和 for (int i = 1; i &lt;= n; i++) &#123;//针对每个节点，找到最小出边 //计算minOut[i]和minSum float min = Float.MAX_VALUE; for (int j = 1; j &lt;= n; j++) &#123; if (a[i][j] &lt; Float.MAX_VALUE &amp;&amp; a[i][j] &lt; min) min = a[i][j]; &#125; if (min == Float.MAX_VALUE) return Float.MAX_VALUE; minOut[i] = min; minSum += min; &#125; //初始化 int[] x = new int[n]; for (int i = 0; i &lt; n; i++) x[i] = i + 1; HeapNode enode = new HeapNode(0, 0, minSum, 0, x); float bestc = Float.MAX_VALUE; //搜索排列空间树 while (enode != null &amp;&amp; enode.s &lt; n - 1) &#123; //非叶节点 x = enode.x; if (enode.s == n - 2) &#123; //当前扩展结点是叶节点的父节点 //再加两条边构成回路 //所构成回路是否优于当前最优解 if (a[x[n - 2]][x[n - 1]] != -1 &amp;&amp; a[x[n - 1]][1] != -1 &amp;&amp; enode.cc + a[x[n - 2]][x[n - 1]] + a[x[n - 1]][1] &lt; bestc) &#123; //找到费用更小的回路 bestc = enode.cc + a[x[n - 2]][x[n - 1]] + a[x[n - 1]][1]; enode.cc = bestc; enode.lcost = bestc; enode.s++; heap.add(enode); Collections.sort(heap); &#125; &#125; else &#123;//内部结点 //产生当前扩展结点的儿子结点 for (int i = enode.s + 1; i &lt; n; i++) &#123; if (a[x[enode.s]][x[i]] != -1) &#123; //可行儿子结点 float cc = enode.cc + a[x[enode.s]][x[i]]; float rcost = enode.rcost = minOut[x[enode.s]]; float b = cc + rcost;//下界 if (b &lt; bestc) &#123; //子树可能含有最优解，结点插入最小堆 int[] xx = new int[n]; for (int j = 0; j &lt; n; j++) xx[j] = x[j]; xx[enode.s + 1] = x[i]; xx[i] = x[enode.s + 1]; HeapNode node = new HeapNode(b, cc, rcost, enode.s + 1, xx); heap.add(node); Collections.sort(heap); &#125; &#125; &#125; &#125; //取下一个扩展结点 enode = heap.poll(); &#125; //将最优解复制到v[1...n] for (int i = 0; i &lt; n; i++) v[i + 1] = enode.x[i]; return bestc; &#125; public static void main(String[] args) &#123; int n = 4;//节点数目 float[][] a = &#123;&#123;0, 0, 0, 0, 0,&#125;, &#123;0, -1, 30, 6, 4&#125;, &#123;0, 30, -1, 5, 10&#125;, &#123;0, 6, 5, -1, 20&#125;, &#123;0, 4, 10, 20, -1&#125;&#125;;//a下标从1开始，0用来凑数；-1表示源点，&gt;0表示权值 LvXingShouhuoyuan b = new LvXingShouhuoyuan(a);//初始化对象 int[] v = new int[n + 1]; System.out.println(&quot;输出:\\n&quot; + &quot;最短回路长为：&quot; + (int)(b.bbTsp(v))); System.out.print(&quot;最短回路为：&quot;); for (int i = 1; i &lt;= n; i++) &#123; System.out.print(v[i] + &quot; &quot;); &#125; &#125;&#125; 运行结果: 原作者：https://blog.csdn.net/xie__jin__cheng/article/details/90710401","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"},{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"java实验四","date":"2021-04-07T11:51:14.000Z","path":"2021/04/07/java实验四/","text":"实验四：图形界面及应用系统的设计实验目的： 了解 java.awt 包及 Swing 的新增特性。 了解 Java 系统图形用户界面的基本工作原理和界面设计的步骤。 掌握图形用户界面各种布局策略的设计与使用。 了解图形用户界面的事件响应机制，并能进行常用的事件处理，如按钮事件、键盘事件、窗口事件等。 掌握图形用户界面各种常用的基本组件的使用方法及其事件响应。 了解面向对象数据流的概念, 了解常见的输入输出流以及分类。 掌握文件描述，顺序处理，随机访问处理的方法 掌握文件与目录的操作过程。 实验内容及要求：制作如图一个留言板的界面，并按要求加入所需控件，并能按要求进行窗口控件的布局。并按要求为按钮、文本框、窗口添加事件，使之实现提交显示留言，清屏，留言至顶和至尾。要求文本框能自动产生滚动条，界面美观。注意： 通过两个文本文件存储表情和留言内容。 Expression.dat：用于存储表情，如：微笑、大哭、流泪等；每个表情占一行。 Msg.dat：用于存储留言信息，留言信息格式为： [2019-10-04 12:35] 你微笑地说:今天下午去图书馆吗？ 其中：时间是提交留言的时间，每条留言一行。 窗口启动的时候（或点击“查看”按钮时），从 Msg.dat 文件中读出所有留言记录，显示在文本框中；从 Expression.dat 文件中读出所有表情记录，显示在表情下拉列表中。将 Msg.dat 中所有留言记录，倒序显示在文本域中。 点击提交按钮，将表单内容存入文件，同时刷新文本框的留言内容。 “清屏”代表清除留言框内容，“至顶”和“至尾”功能是当留言内容过多时，将滚动条滚动到最上面或最下面，实现过程为移动文本区域里面的光标，使其指向第一个位置和最后一个位置。（设置光标位置函数为：setCaretPosition（int 位置）） （选作）增加“表情维护”按钮，在新窗口修改表情文件的内容 （选作）增加“删除留言”按钮，在新窗口通过选择数字或全部删除相关的留言内容 时间安排：前3学时，做界面和基本的显示效果操作事件，后3学时将文件操作引入相关的事件中。 ※※※※本实验代码转载于nice bug※※※※原作者:https://blog.csdn.net/qq_45441117/article/details/111334825如果你有时间可以去学习一下：https://blog.csdn.net/xietansheng/article/details/72814492有到了面向CSDN编程了，我只是大自然搬运工！我也才开始学java(二级都没过纯小白！！！！)加了一些注释 左上角图标我换了 表情文件 消息记录 Framers类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220//implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用 ，ActionListener, KeyListener键盘监听、动作监听public class Framers extends JFrame implements ActionListener, KeyListener &#123; JTextArea t1;//留言框区域 JButton but1, but2, but3, but4, but5, but6;//按钮 JComboBox looks;//下拉表情列表组件 JTextField lo;//文本框 JLabel lbl1, lbl2, lbl3;//标签，构成留言框的每个部分 //有参构造方法 public Framers(String title) &#123; super(title);//父类调用子类标题 this.setSize(1000, 600);//设置留言框大小 this.setFont(new Font(&quot;System&quot;, Font.PLAIN, 14)); //下面都只是为了把标题居中不够好 Font f = this.getFont(); FontMetrics fm = this.getFontMetrics(f); int x = fm.stringWidth(title); int y = fm.stringWidth(&quot; &quot;); int z = this.getWidth() / 2 - (x / 2); int w = z / y; String pad = &quot; &quot;; pad = String.format(&quot;%&quot; + w + &quot;s&quot;, pad); this.setTitle(pad + title); this.setIconImage(new ImageIcon(&quot;src./favicon.jpg&quot;).getImage());//设置左上角图标 this.winInit();//留言框初始化 this.setVisible(true); &#125; public void winInit() &#123; lbl1 = new JLabel(&quot;留言板&quot;, 0);// horizontalAlignment: 标签内容（在标签内）的水平对其方式（竖直方向默认居中, 可通过方法设置） lbl2 = new JLabel(&quot;你&quot;); lbl3 = new JLabel(&quot;地说：&quot;); t1 = new JTextArea(&quot;留言内容：\\n&quot;); t1.setLineWrap(true);//自动换行 t1.setEditable(false);//设置留言板内容不可更改 t1.setBackground(new Color(0xFF, 0xFF, 0xEE));//设置留言版的背景色 t1.setForeground(new Color(0, 0, 255));//设置留言板字体颜色 lo = new JTextField(35);//设置输入框长度 looks = new JComboBox();// looks.addItem(&quot;哭着&quot;);// looks.addItem(&quot;笑着&quot;);// looks.addItem(&quot;哈哈哈哈&quot;);// looks.addItem(&quot;乐呵呵&quot;);// looks.addItem(&quot;笑嘻嘻&quot;); this.loadExp(); //文件加载表情 //创建按钮 but1 = new JButton(&quot;提交&quot;); but2 = new JButton(&quot;清屏&quot;); but3 = new JButton(&quot;至顶&quot;); but4 = new JButton(&quot;至尾&quot;); but5 = new JButton(&quot;查看&quot;); but6 = new JButton(&quot;删除&quot;); //给标签、文本区域、按钮、表情下拉列表设置字体，宋体 加粗，大小：20磅 lbl1.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); lbl2.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); lbl3.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); t1.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); lo.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); but1.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); but2.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); but3.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); but4.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); but5.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); but6.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); looks.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20)); // 添加 和 移除 按钮的点击事件 but1.addActionListener(this); //提交 but2.addActionListener(this); //清屏 but3.addActionListener(this); //至顶 but4.addActionListener(this); //至尾 but5.addActionListener(this); //查看 but6.addActionListener(this); //删除 //键盘输入监听器 lo.addKeyListener(this); //创建不同面板 JPanel pEast = new JPanel(); JPanel pSouth = new JPanel(); JScrollPane scroll = new JScrollPane(t1, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);//加滚轮 垂直滚动条一直显示, 水平滚动条从不显示 pEast.setLayout(new GridLayout(8, 1, 0, 30));//东方为网格布局 指定 行数 和 列数 的网格布局, 并指定 水平 和 竖直 网格间隙 //面板 pSouth.add(lbl2); pSouth.add(looks); pSouth.add(lbl3); pSouth.add(lo); pSouth.add(but1); pEast.add(but2); pEast.add(but3); pEast.add(but4); pEast.add(but5); pEast.add(but6); //将面板加入窗口 位置 add(scroll, &quot;Center&quot;); add(lbl1, &quot;North&quot;); add(pEast, &quot;East&quot;); add(pSouth, &quot;South&quot;); this.loadMsg(); //加载文件中的内容 this.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125; //加载文件中的表情 public void loadExp() &#123; looks.removeAllItems(); try &#123; FileReader Re = new FileReader(&quot;Expression.dat&quot;); BufferedReader br = new BufferedReader(Re); String exp; while ((exp = br.readLine()) != null) &#123; looks.addItem(exp); &#125; br.close(); &#125; catch (IOException e1) &#123; System.out.println(&quot;读取文件失败&quot; + e1); &#125; &#125; //加载文件中的留言内容 public void loadMsg() &#123; t1.setText(&quot;留言内容：\\n&quot;); try &#123; BufferedReader br = new BufferedReader(new FileReader(&quot;msg.dat&quot;)); String msg; while ((msg = br.readLine()) != null) &#123; t1.insert(msg + &quot;\\n&quot;, 6); &#125; br.close(); &#125; catch (IOException e1) &#123; System.out.println(&quot;读文件失败&quot; + e1); &#125; &#125; //提交留言过程 public void msgSubmit() &#123; if (lo.getText().trim().length() == 0) return; //获取当前时间 Date crr = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-hh:mm:ss&quot;);//初始化时间格式 String curr = sdf.format(crr); String loms = &quot;[&quot; + curr + &quot;]&quot; + &quot;你&quot; + looks.getSelectedItem() + &quot;地说：&quot; + lo.getText(); t1.insert(loms + &quot;\\n&quot;, 6); //写入msg.dat文件 File f = new File(&quot;Msg.dat&quot;); try &#123; FileWriter fw = new FileWriter(f, true);//追加 fw.write(loms + &quot;\\r\\n&quot;); fw.close(); &#125; catch (IOException e1) &#123; System.out.println(&quot;写入文件失败&quot; + e1); &#125; lo.setText(&quot;&quot;); &#125; public void delete() &#123; String lom = &quot; &quot;; File f = new File(&quot;Msg.dat&quot;); try &#123; FileWriter fw = new FileWriter(f);//追加 fw.write(lom + &quot;\\r\\n&quot;); fw.close(); &#125; catch (IOException e1) &#123; System.out.println(&quot;写入文件失败&quot; + e1); &#125; &#125; public void actionPerformed(ActionEvent e) &#123; String com = e.getActionCommand(); switch (com) &#123; case &quot;提交&quot;: &#123; msgSubmit(); break; &#125; case &quot;清屏&quot;: &#123; t1.setText(&quot;留言内容：\\n&quot;); break; &#125; case &quot;至顶&quot;: &#123; t1.setCaretPosition(0); break; &#125; case &quot;至尾&quot;: &#123; t1.setCaretPosition(t1.getText().length() - 1); break; &#125; case &quot;查看&quot;: &#123; this.loadMsg(); break; &#125; case &quot;删除&quot;: &#123; this.delete(); break; &#125; &#125; &#125; @Override public void keyTyped(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; @Override public void keyPressed(KeyEvent e) &#123; // TODO Auto-generated method stub if (e.getKeyCode() == 10) &#123; msgSubmit(); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; // TODO Auto-generated method stub &#125;&#125; FramelessDemo测试类123456public class FramelessDemo &#123; public static void main(String[] args) &#123; Framers fr = new Framers(&quot;小小留言板&quot;); fr.setVisible(true); &#125;&#125; 运行结果：","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"}]},{"title":"回朔法","date":"2021-04-07T11:18:16.000Z","path":"2021/04/07/回朔法/","text":"利用回朔法求解 0-1 背包问题我们有 n 种物品，物品 j 的重量为 wj，价格为 pj。我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为 c。如果限定每种物品只能选择 0 个或 1 个。有六件物品，体积和价值见下表，背包容量为 25。 i 1 2 3 4 5 6 w(体积) 11 7 9 12 3 10 v(价值) 10 5 7 9 2 12 求解思想： 定义问题解空间； 确定易于搜索的解空间结构，该问题的解空间结构为子集树； 采用深度优先方式搜索解空间，同时要及时剪枝，避免无效搜索。该问题的限界函数为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class _01KnapsackProblem &#123; public int[] weight; public int[] value; public int[] take; int curWeight = 0; int curValue = 0; int bestValue = 0; int[] bestChoice; int count; int maxWeight = 0; public void init(int[] weight, int[] value, int maxWeight) &#123; if (weight == null || weight.length == 0 || value == null || value.length == 0 || weight.length != value.length || maxWeight &lt;= 0) &#123; System.out.println(&quot;输入数据有错！&quot;); return; &#125; this.value = value; this.weight = weight; this.maxWeight = maxWeight; count = value.length; take = new int[count]; bestChoice = new int[count]; &#125; public int[] maxValue(int x) &#123; //走到了叶子节点 if (x &gt; count - 1) &#123; //更新最优解 if (curValue &gt; bestValue) &#123; bestValue = curValue; for (int i = 0; i &lt; take.length; i++) &#123; bestChoice[i] = take[i]; &#125; &#125; &#125; else &#123; //遍历当前节点（物品）的子节点：0 不放入背包 1：放入背包 for (int i = 0; i &lt; 2; i++) &#123; take[x] = i; if (i == 0) &#123; //不放入背包，接着往下走 maxValue(x + 1); &#125; else &#123; //约束条件，如果小于背包容量 if (curWeight + weight[x] &lt;= maxWeight) &#123; //更新当前重量和价值 curWeight += weight[x]; curValue += value[x]; //继续向下深入 maxValue(x + 1); //回溯法重要步骤，个人感觉也是精华所在。 // 当从上一行代码maxValue出来后，需要回溯容量和值 curWeight -= weight[x]; curValue -= value[x]; &#125; &#125; &#125; &#125; return bestChoice; &#125; public static void main(String[] args) &#123; _01KnapsackProblem bt=new _01KnapsackProblem(); bt.init(new int[]&#123;11,7,9,12,3,10&#125;,new int[]&#123;10,5,7,9,2,12&#125;,25); int[] result = bt.maxValue(0); System.out.print(&quot;输出:\\n&quot;+&quot;选择的物品是:&quot;); for (int i = 0; i &lt;=bt.bestChoice.length-1 ; i++) &#123; if (bt.bestChoice[i] == 1) &#123; System.out.print(i+1+&quot;,&quot;); &#125; &#125; System.out.println(&quot;\\n此时价值最大，即&quot;+bt.bestValue); &#125;&#125; 运行结果: 参考链接1：https://blog.csdn.net/jarvischu/article/details/16067319参考链接2：https://blog.csdn.net/u012545728/article/details/81746467?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158616323419726869000059%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&amp;request_id=158616323419726869000059&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task-blog-all_SOOPENSEARCH-3","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"},{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"贪心算法","date":"2021-04-04T06:24:12.000Z","path":"2021/04/04/最小生成树/","text":"最小生成树Prim 算法计算最小生成树。最小生成树的定义：最小生成树是一副连通加权无向图中一棵权值最小的生成树。假设给定无向图 G 一共有 n 个顶点，那么最小生成树一定会有 n-1 条边。 求解思想： 选定一个点做为一个集合 a，剩下的点为另一个集合 b； 将横跨两个集合且权重在其中最小的边加入最小生成树； 将刚刚加入最小生成树的边中不在集合 a 中的点加入集合 a，直到所有的点加入集合 a。MGraph类123456789101112public class MGraph &#123; /*图的邻接矩阵表示*/ int nodes; //图中结点数目 char data[]; //存放结点数据 int[][] weight; //存放边 public MGraph(int ve) &#123; nodes = ve; data = new char[ve]; weight = new int[ve][ve]; &#125;&#125; MinTree类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MinTree &#123; private static int sum = 0;//最小权值 /*创建图的邻接矩阵*/ public void CreateGraph(MGraph graph, int nodes, char data[], int[][] weight) &#123; int i, j; for (i = 0; i &lt; nodes; i++) &#123; graph.data[i] = data[i]; for (j = 0; j &lt; nodes; j++) &#123; graph.weight[i][j] = weight[i][j]; &#125; &#125; &#125; public void Prim(MGraph graph, int v) &#123; /*graph为图的邻接矩阵表示，v为起始顶点*/ int[] visited = new int[graph.nodes]; // visited[]标记结点是否被访问过 for (int i = 0; i &lt; graph.nodes; i++) &#123; //初始化visited[] visited[i] = 0; &#125; visited[v] = 1; int h1 = -1, h2 = -1; //记录边的弧尾和弧头 int wineWeight = 10000;//minWeight记录最小权重 for (int k = 1; k &lt; graph.nodes; k++) &#123; //nodes个顶点，最小生成树中有nodes-1条边 for (int i = 0; i &lt; graph.nodes; i++) &#123; //i顶点表示被访问过的顶点 for (int j = 0; j &lt; graph.nodes; j++) &#123; // j顶点表示未被访问过的顶点 if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; wineWeight) &#123; //寻找已访问的顶点与未访问的定点间的权值最小的边 wineWeight = graph.weight[i][j]; h1 = i; h2 = j; &#125; &#125; &#125; System.out.println(graph.data[h1] + &quot;,&quot; + graph.data[h2]); sum += wineWeight; visited[h2] = 1; //标记h2被访问过 wineWeight = 10000; &#125; &#125; public static void main(String args[]) &#123; char[] data = new char[]&#123;&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;&#125;; int nodes = data.length; int[][] weight = new int[][]&#123; &#123;0, 6, 1, 5, 10000, 10000&#125;, &#123;6, 0, 5, 10000, 3, 10000&#125;, &#123;1, 5, 0, 5, 6, 4&#125;, &#123;5, 10000, 5, 0, 10000, 2&#125;, &#123;10000, 3, 6, 10000, 0, 6&#125;, &#123;10000, 10000, 4, 2, 6, 0&#125; &#125;; System.out.println(&quot;输出:\\n&quot; + &quot;依次构成树的边为（用两个顶点表示边）:&quot;); MGraph graph = new MGraph(nodes);//初始化邻接矩阵 MinTree mt = new MinTree();//初始化最小生成树 mt.CreateGraph(graph, nodes, data, weight);//创建邻接矩阵，graph:临界矩阵类型, nodes:节点数, data:结点名字, weight:权值 mt.Prim(graph, 0);// System.out.print(&quot;最小权合值:&quot; + sum); &#125;&#125; 运行结果:参考链接1：https://blog.csdn.net/yxmmao/article/details/51586411参考链接2：https://cloud.tencent.com/developer/article/1056927?from=information.detail%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98prim%E7%AE%97%E6%B3%95","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"},{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"贪心算法","date":"2021-04-03T09:24:06.000Z","path":"2021/04/03/有向图/","text":"有向图给定带权有向图 G=(V,E)，其中每条边的权是非负实数。另外，还给定 V 中的一个顶点，称为源。现在要计算从源到所有其它各顶点的最短路长度。这里路的长度是指路上各边权之和。 求解思想： 采用二维数组邻接矩阵的形式储存图并将图初始化； 选择其中一个顶点作为计算最短路径的起点。 构造一个一维数组 dis[n]，其中 n 是顶点个数，dis 用来记录最短路径距离。初始化 dis，其值为图中各点到起点的直接距离（即邻接顶点记为其权值，不相邻的顶点记为∞）； 每次在 dis 数组中找出最小值，该值就是起点到该点的最短路径距离，（可以将该点加一个标志位已记录该点路径已确定； 在加入了一个新的确定了点之后就需要更新 dis 数组，看其余点能否通过这个确定的点到达起始点且距离能够更短。 重复 4、5 步，直到所有点都找到了最短路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * @author by LiuKui * @date 2021/4/3. */public class Greedy &#123; static int N = 5, M = 1000;//N为点数量 static int[][] c = new int[N + 1][N + 1];//存取所有有向图的权值 static int[] dist = new int[N + 1];//记录源点到目标点的距离 static int[] prev = new int[N + 1];//记录最短路径经过的点 public static void main(String[] args) &#123; int v = 1; init();//初始化数组，v表示源点，表示终点 Dijkstra(N, 1, dist, prev, c); System.out.println(&quot;输出:&quot;); for (int i = 2; i &lt;= N; i++) &#123; System.out.println(&quot;从1出发到&quot; + i + &quot;的最短距离为:&quot; + dist[i]); &#125; System.out.println(&quot;=======================&quot;); for (int i = 2; i &lt;= N; i++) &#123; System.out.print(&quot;从1出发到&quot; + i + &quot;的最短路径为:&quot;); Traceback(v, i, prev); System.out.println(&quot; &quot;); &#125; &#125; public static void Dijkstra(int n, int v, int[] dist, int[] prev, int c[][]) &#123; Boolean[] s = new Boolean[N + 1]; for (int i = 1; i &lt;= n; i++) &#123; dist[i] = c[v][i];//dist[i]表示当前从源到顶点i的最短特殊路径长度 s[i] = false; if (dist[i] == M) &#123; prev[i] = 0;//记录从源到顶点i的最短路径i的前一个顶点 &#125; else &#123; prev[i] = v; &#125; &#125; dist[v] = 0; s[v] = true; for (int i = 1; i &lt; n; i++) &#123; int temp = M; int u = v;//上一顶点 //取出V-S中具有最短特殊路径长度的顶点u for (int j = 1; j &lt;= n; j++) &#123; if ((!s[j]) &amp;&amp; (dist[j] &lt; temp)) &#123; u = j; temp = dist[j]; &#125; &#125; s[u] = true; //根据作出的贪心选择更新Dist值 for (int j = 1; j &lt;= n; j++) &#123; if ((!s[j]) &amp;&amp; (c[u][j] &lt; M)) &#123; int newdist = dist[u] + c[u][j]; if (newdist &lt; dist[j]) &#123; dist[j] = newdist; prev[j] = u; &#125; &#125; &#125; &#125; &#125; //输出最短路径 v源点，i终点 static void Traceback(int v, int i, int[] prev) &#123; if (v == i) &#123; System.out.print(i); return; &#125; else &#123; Traceback(v, prev[i], prev); System.out.print(&quot;--&gt;&quot; + i); &#125; &#125; public static void init() &#123; for (int i = 1; i &lt;= N; i++) &#123; dist[i] = 0; for (int j = 1; j &lt;= N; j++) &#123; c[i][j] = M; &#125; &#125; //为了测试方便，直接码出来了 c[1][2] = 10; c[1][4] = 30; c[1][5] = 100; c[2][3] = 50; c[3][5] = 10; c[4][5] = 60; c[4][3] = 20; &#125;&#125; 运行结果: 参考链接：https://blog.csdn.net/liufeng_king/article/details/8726066","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"},{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"动态规划算法实现","date":"2021-03-31T11:26:35.000Z","path":"2021/03/31/多段图/","text":"多段图问题若存在一个有向加权图 G，且 G 能分出起点和终点以及中间的 n 的阶段，求起点到终点的最短（长）距离。 求解的思想： 将图中的顶点划分 5 个阶段，k 每个阶段有几种供选择的点 s 当前状态应在前一个状态的基础上获得。决策需要满足规划方程 规划方程：f(k)表示状态 k 到终点状态的最短距离。初始条件：f(k)=0，k=0;f(k-1)=min{f(k)+W(k-1,k)}其中 W(k-1,k)表示状态 k-1 到状态 k 的距离 ※※※※以下代码用的向前处理法与老师不同，但都是最短路径※※※※1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Duoduantu &#123; static int N = 13, K = 5, INF = 1000; static int[][] c = new int[N][N]; //c[i][j]表示i到j的花费 static int[] cost = new int[N]; //cost[i]表示到结点i的最小花费 static int[] d = new int[N]; //d[i]表示由结点i指向的最小成本边的另一端的结点 static int[] P = new int[K]; // 每一阶段最短路径成本 public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); init(); //初始化 fGraph(); int k = K; int sum = 0; int n = N - 1; while (k != 1)//遍历每个阶段的最短路径成本 &#123; sum += cost[n]; n = d[n]; list.add(n); k--; &#125; System.out.println(&quot;输出:&quot; + &quot;\\n&quot; + &quot;最短路径为:&quot;); for (int i = list.size() - 1; i &gt;= 0; i--) &#123; System.out.print(list.get(i) + &quot;-&gt;&quot;); &#125; System.out.println(&quot;12&quot;); System.out.println(&quot;最小成本路径为:&quot; + sum); &#125; public static void fGraph() &#123; int min; for (int j = N - 1; j &gt; 0; j--)//向前处理方法 &#123; min = INF; //for (int i = 1; i &lt; N; i++) for (int i = j - 1; i &gt; 0; i--)//从j - 1开始可以减少比较次数 &#123; if (c[i][j] != INF &amp;&amp; cost[j] + c[i][j] &lt; min)//找出结点r, 满足&lt;j, r&gt;∈E且使c(j,r)+COST(r)值最小 &#123; min = cost[i] + c[i][j]; d[j] = i; &#125; &#125; cost[j] = min;//数组cost[i]保留到结点i的最短边的权值 &#125; &#125; public static void init() &#123; for (int i = 1; i &lt; N; i++) &#123; cost[i] = 0; for (int j = 1; j &lt; N; j++) &#123; c[i][j] = INF; &#125; &#125; //为了测试方便，直接码出来了 c[1][2] = 9;c[1][3] = 7;c[1][4] = 3;c[1][5] = 2; c[2][6] = 4;c[2][7] = 2;c[2][8] = 1; c[3][6] = 2;c[3][7] = 7; c[4][8] = 11; c[5][7] = 11;c[5][8] = 8; c[6][9] = 6;c[6][10] = 5; c[7][9] = 4;c[7][10] = 3; c[8][10] = 5;c[8][11] = 6; c[9][12] = 4; c[10][12] = 2; c[11][12] = 5;&#125; 参考链接1:https://blog.csdn.net/qq_30836691/article/details/101230958参考链接2:https://blog.csdn.net/ncepuzhuang/article/details/8923790","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"},{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"动态规划算法实现","date":"2021-03-30T15:07:49.000Z","path":"2021/03/30/背包问题/","text":"01背包问题用动态规划算法实现 0-1 背包问题，在计算机上编程实现。我们有 n 种物品，物品 j 的重量为 wj，价格为 pj。我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为 c。如果限定每种物品只能选择 0 个或 1 个。 有六件物品，体积和价值见下表，背包容量为 25。 i 1 2 3 4 5 6 w(体积) 11 7 9 12 3 10 v(价值) 10 5 7 9 2 12 求解的思想： 背包容量不足以放下第 i 件物品，只能选择不拿：m[ i ][ j ] = m[ i-1 ][ j ] 背包容量可以放下第 i 件物品，我们就要考虑拿这件物品是否能获取更大的价值。 综合以上两种情况可以得到状态转换方程 ： f[i,j]=Max{ f[i-1,j-Wi]+Vi( j &gt;= Wi ),f[i-1,j] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Zero_one &#123; public int packageweight = 25;//背包的总容量 public int productnum = 6;//物品总数 public int[] weights = &#123;11, 7, 9, 12, 3, 10&#125;;//每个物品的重量 public int[] values = &#123;10, 5, 7, 9, 2, 12&#125;;//每个物品的价值 public static void main(String[] args) &#123; Zero_one zero_one = new Zero_one(); int[][] m = zero_one.initpkdata(); int[][] res = zero_one.result(m); System.out.println(&quot;输出:&quot;); System.out.println(&quot;最大价值：&quot; + res[zero_one.productnum][zero_one.packageweight]); System.out.print(&quot;装入的物品编号是:&quot;); zero_one.findproducts(res); &#125; /** * 初始化背包 * m[i][0] = 0 :表示背包重量为0，不能装东西，因此价值全为0 * m[0][j] = 0 :表示没有可以装的物品，因此价值为0 */ public int[][] initpkdata() &#123; int[][] m = new int[this.productnum + 1][this.packageweight + 1]; for (int i = 0; i &lt;= this.productnum; i++) &#123; m[i][0] = 0; &#125; for (int j = 0; j &lt;= this.packageweight; j++) &#123; m[0][j] = 0; &#125; return m; &#125; public int[][] result(int[][] arr) &#123; for (int i = 1; i &lt;= this.productnum; i++) &#123; for (int j = 1; j &lt;= this.packageweight; j++) &#123; // 当第i件物品重量大于当前包的容量 则放不进去 // 所以当前背包所含价值等于前i-1件商品的价值 if (this.weights[i - 1] &gt; j) &#123; arr[i][j] = arr[i - 1][j]; &#125; /*当第i件物品能放进去时 1 放入物品，价值为：arr[i-1][j-(int)this.weights.get(i-1)] + (int)this.values.get(i-1) 2不放入物品，价值为前i-1件物品价值和：arr[i][j] = arr[i-1][j]; 此时最大价值为上述两种方案中最大的一个 */ else &#123; if (arr[i - 1][j] &lt; arr[i - 1][j - this.weights[i - 1]] + this.values[i - 1]) &#123; arr[i][j] = arr[i - 1][j - this.weights[i - 1]] + this.values[i - 1]; &#125; else &#123; arr[i][j] = arr[i - 1][j]; &#125; &#125; &#125; &#125; return arr; &#125; public void findproducts(int[][] arr) &#123; int j = this.packageweight; for (int i = 1; i &lt;= this.productnum; i++) &#123; if (arr[i][j] &gt; arr[i - 1][j]) &#123; System.out.print(i + &quot;,&quot;);//输出选中的物品的编号 j = j - this.weights[i - 1]; if (j &lt; 0) &#123; break; &#125; &#125; &#125; &#125;&#125; 原文章链接:https://blog.csdn.net/qq_35443700/article/details/102816747","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"},{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://luikui.xyz/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"linux-c多线程","date":"2021-03-24T11:15:04.000Z","path":"2021/03/24/linux-c多线程/","text":"windows环境运行linux编译c程序/linux环境C语言下多线程windows环境运行linux编写c源程序 由于我用的vscode，所以用c++编译c程序所以多了两行 linux环境C语言下多线程源程序:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* 以生产者和消费者模型问题来阐述Linux线程的控制和通信你生产者线程将生产的产品送入缓冲区，消费者线程则从中取出产品。缓冲区有N个，是一个环形的缓冲池。*/#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define BUFFER_SIZE 16struct prodcons&#123;int buffer[BUFFER_SIZE];/*实际存放数据的数组*/pthread_mutex_t lock;/*互斥体lock，用于对缓冲区的互斥操作*/int readpos,writepos; /*读写指针*/pthread_cond_t notempty;/*缓冲区非空的条件变量*/pthread_cond_t notfull;/*缓冲区未满 的条件变量*/&#125;;/*初始化缓冲区*/void pthread_init( struct prodcons *p)&#123;pthread_mutex_init(&amp;p-&gt;lock,NULL);pthread_cond_init(&amp;p-&gt;notempty,NULL);pthread_cond_init(&amp;p-&gt;notfull,NULL);p-&gt;readpos = 0;p-&gt;writepos = 0;&#125;/*将产品放入缓冲区，这里是存入一个整数*/void put(struct prodcons *p,int data)&#123;pthread_mutex_lock(&amp;p-&gt;lock);/*等待缓冲区未满*/if((p-&gt;writepos +1)%BUFFER_SIZE ==p-&gt;readpos)&#123;pthread_cond_wait(&amp;p-&gt;notfull,&amp;p-&gt;lock);&#125;p-&gt;buffer[p-&gt;writepos] =data;p-&gt;writepos++;if(p-&gt;writepos &gt;= BUFFER_SIZE)p-&gt;writepos = 0;pthread_cond_signal(&amp;p-&gt;notempty);pthread_mutex_unlock(&amp;p-&gt;lock);&#125;/*从缓冲区取出整数*/int get(struct prodcons *p)&#123;int data;pthread_mutex_lock(&amp;p-&gt;lock);/*等待缓冲区非空*/if(p-&gt;writepos == p-&gt;readpos)&#123;pthread_cond_wait(&amp;p-&gt;notempty ,&amp;p-&gt;lock);//非空就设置条件变量notempty&#125;/*读书据，移动读指针*/data = p-&gt;buffer[p-&gt;readpos];p-&gt;readpos++;if(p-&gt;readpos == BUFFER_SIZE)p-&gt;readpos = 0;/*设置缓冲区未满的条件变量*/pthread_cond_signal(&amp;p-&gt;notfull);pthread_mutex_unlock(&amp;p-&gt;lock);return data;&#125;/*测试：生产站线程将1 到1000的整数送入缓冲区，消费者线程从缓冲区中获取整数，两者都打印信息*/#define OVER (-1)struct prodcons buffer;void *producer(void *data)&#123;int n;for( n=0;n&lt;1000;n++)&#123;printf(&quot;%d ------&gt;\\n&quot;,n);put(&amp;buffer,n);&#125;put(&amp;buffer,OVER);return NULL;&#125;void *consumer(void *data)&#123;int d;while(1)&#123;d = get(&amp;buffer);if(d == OVER)break;elseprintf(&quot;-----&gt;%d\\n&quot;,d);&#125;return NULL;&#125;int main()&#123;pthread_t th_p,th_c;void *retval;pthread_init(&amp;buffer);pthread_create(&amp;th_p,NULL,producer,0);pthread_create(&amp;th_c,NULL,consumer,0);/*等待两个线程结束*/pthread_join(th_p, &amp;retval);pthread_join(th_c,&amp;retval);return 0;&#125; 原文章链接:链接运行效果: 如果遇到pthread.h问题，请移步下方链接原文章链接:链接","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"},{"name":"C语言","slug":"C语言","permalink":"https://luikui.xyz/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"linux-c语言","date":"2021-03-24T09:50:50.000Z","path":"2021/03/24/linux-c语言/","text":"linux环境运行c程序&emsp; 我选用的是ubuntu18.04版本 (Windows子系统) &emsp; 为了避免权限问题获取管理员权限&emsp; 最好先看安装vim没有（我已经装过了）&emsp; 更行软件安装gcc（我也装过了）&emsp; 创建workspace并进入&emsp; workspace目录并创建main.cpp&emsp; Vim 编辑器进入main.cpp&emsp; 按i进入编辑模式，在而是ESC退到命令模式，按shif+:进入底线命令模式输入wq存盘退出&emsp; 编译mian.cpp &emsp; 运行：","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"},{"name":"C语言","slug":"C语言","permalink":"https://luikui.xyz/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"java实验三","date":"2021-03-21T16:26:56.000Z","path":"2021/03/22/java实验三/","text":"※※※※可以参考！但请不要原封不动照搬！※※※※实验三 身份证号码的分析3.2 实验内容及要求身份证号码验证及个人信息输出。在网页、管理信息系统中，我们经常会要求用户输入身份证号码，由于身份证号码较长，经常容易产生录入错误，本验证可以有效防止用户录用错误。其实身份证中还包含了用户的个人信息，包含出生地、生日、性别的等内容 如：51 01 03 19XX 01 03 028 X 为：省 市 区 出生年 月 日 顺序码 校验码 身份证验证主要包含： 位数错误：正确应该为 18 位。 字符错误：前面 17 个应该是数字，最后一位可以为‘X’或‘x’； 校验码错误：身份证的最后一位为校验码，校验码是用于验证前面的数字是否有错误，校验码运算规则： （1）先将最后一位设定为 0。（2）效验码的计算公式为：(Σ (ai×wi))%11 其中：i 是从右向左的包括效验码在内的序号（1－18） ai 是第 i 位的数字 wi 是第 i 位上的加权因子，其数值依据公式 wi=(2(i-1))%11，（计算 ab：函数为java.lang.Math.pow(a,b)） i，ai，wi 的对应关系如下： 证号码: 5 1 0 1 0 1 1 9 8 8 0 8 0 8 0 1 2 0 i: 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 ai: 5 1 0 1 0 1 1 9 8 8 0 8 0 8 0 1 2 0 wi: 用公式计算 2^(i-1)%11 …… 9 10 5 8 4 2 1 （3）求出(Σ (ai×wi))%11 之后依据下表得到效验码： (Σ (ai×wi))%11 0 1 2 3 4 5 6 7 8 9 10 效验码值 1 0 X 9 8 7 6 5 4 3 2 （4）计算 ab：函数为：java.lang.Math.pow(a,b) 1234567891011121314151617181920212223242526272829303132要求： （1）编写一个身份证类，包含一个属性：身份证号；三个验证函数；一个信息输出函数。（2）编写一个测试类，可从键盘上输入一个身份证号码，产生一个身份证对象，然后调用其相关方法对身份证号码进行验证，没有通过验证的话，提示错误信息并让用户重新输入，如果通过验证，则输出该人的信息。代码框架如下：class CardID&#123;private String cardNum; public void setCardNum(String cardNum)&#123;//换一个号码this. cardNum= cardNum; &#125;1 位数错误验证public boolean lengthVerify()&#123; &#125;2 字符错误验证public boolean charVerify()&#123; &#125;3 校验码错误验证public boolean checkcodeVerify()&#123; //测试时请将每一轮的 i,ai,wi,sum 输出，避免出错，成功后不再输出 &#125;4 信息输出public void output()&#123; //按要求输出个人信息 &#125;&#125;class CardIDDemo&#123;public static void main(String []args)&#123;//用死循环反复测试输入、验证、输出//注意第一步验证失败不能进入第二步，第二步失败不能进入第三步，所有验证通过才能进行输出。 &#125; &#125; Card类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;/** * @author by LiuKui * @date 2021/3/3. */public class CardID &#123; private String cardNum; public int Y; public int birDay, birYear, birMonth, dif, sex, day, month, year; //出生日 年 月，年龄，性别，现在日 月 年 public String curr; public boolean z; public void setCardNum(String cardNum) &#123;//换一个号码 this.cardNum = cardNum; &#125; public boolean lengthVerify() &#123;//1 位数错误验证 return this.cardNum.length() == 18; &#125; public boolean charVerify() &#123;//2 字符错误验证 boolean A = true; char[] Arr = cardNum.toCharArray();//转化成字符数组 //判断是否是数字 for (int i = 0; i &lt; cardNum.length(); i++) &#123; if (Arr[i] - &#x27;0&#x27; &lt; 0 || Arr[i] - &#x27;0&#x27; &gt; 9) &#123; A = false; break; &#125; &#125; //判断最后一维是否是X或x if (Arr[cardNum.length() - 1] == &#x27;x&#x27; || Arr[cardNum.length() - 1] == &#x27;X&#x27;) &#123; A = true; &#125; return A; &#125; public boolean checkCodeVerify() &#123;//3 校验码错误验证 // 测试时请将每一轮的 i,ai,wi,sum 输出，避免出错，成功后不再输出 String testNum = this.cardNum.substring(0, 17) + &quot;0&quot;;//提取字符串中介于两个指定下标之间的字符 int i, ai, wi, sum = 0; for (i = 18; i &gt;= 1; i--) &#123; ai = testNum.charAt(18 - i) - 48; wi = (int) Math.pow(2, i - 1) % 11; sum += ai * wi; &#125; int mod = sum % 11; char[] last = &#123;&#x27;1&#x27;, &#x27;0&#x27;, &#x27;X&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;7&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;&#125;; System.out.println(&quot;正确的校验码为：&quot; + last[mod]); return this.cardNum.toUpperCase().charAt(17) == last[mod]; &#125; public void output() &#123;//4 信息输出 //按要求输出个人信息 birYear = Integer.parseInt(cardNum.substring(6, 10)); birDay = Integer.parseInt(cardNum.substring(12, 14)); birMonth = Integer.parseInt(cardNum.substring(10, 12)); dif = Y - birYear; sex = Integer.parseInt(cardNum.substring(16, 17)); Date crr = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); curr = sdf.format(crr); String[] D = curr.split(&quot;-&quot;); year = Integer.parseInt(D[0]); day = Integer.parseInt(D[2]); month = Integer.parseInt(D[1]); dif = year - birYear; if (month == birMonth &amp;&amp; day &lt; birDay) &#123; dif--; &#125; if (month &lt; birMonth) &#123; dif--; &#125; System.out.println(&quot;出生日期为：&quot; + birYear + &quot;年&quot; + birMonth + &quot;月&quot; + String.format(&quot;%02d&quot;, birDay) + &quot;日&quot;); //出生日期字符串“1998-05-22” String bornData = cardNum.substring(6, 10) + &quot;-&quot; + cardNum.substring(10, 12) + &quot;-&quot; + cardNum.substring(12, 14);// //计算时间天数// String bornTime;// //月按30天算// System.out.println(&quot;你的年龄为：&quot; + dif + &quot;岁&quot; + bornTime % 365 / 30 + &quot;月&quot; + bornTime % 365 % 30 + &quot;天&quot;); try &#123; System.out.println(&quot;你的年龄为：&quot; + calTimeAgo(sdf.parse(bornData))); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; if (sex % 2 == 1) &#123; System.out.println(&quot;性别：男&quot;); &#125; else &#123; System.out.println(&quot;性别：女&quot;); &#125; &#125; public static String calTimeAgo(Date date) &#123; Date nowDate = new Date();// if (date.after(nowDate)) &#123;// return &quot;0分钟前&quot;;// &#125; //初始化calendar对象 Calendar nowCal = Calendar.getInstance(); Calendar dateCal = Calendar.getInstance(); //获取当前和出生时间 nowCal.setTime(nowDate); dateCal.setTime(date); //年龄 int yearAgo = nowCal.get(Calendar.YEAR) - dateCal.get(Calendar.YEAR); //计算相差月份 int monthAgo = nowCal.get(Calendar.MONTH) - dateCal.get(Calendar.MONTH); if (monthAgo &lt; 0) &#123; yearAgo--; monthAgo += 12; &#125; int dayAgo = nowCal.get(Calendar.DAY_OF_MONTH) - dateCal.get(Calendar.DAY_OF_MONTH); if (dayAgo &lt; 0) &#123; monthAgo--; //获取当年某个月最大天数 dayAgo += dateCal.getActualMaximum(Calendar.DAY_OF_MONTH); if (monthAgo &lt; 0) &#123; yearAgo--; monthAgo += 12; &#125; &#125; if ( dayAgo == 1) &#123; return (yearAgo &lt; 1 ? &quot;&quot; : (yearAgo + &quot;岁&quot;)) + (monthAgo &lt; 1 ? &quot;&quot; : (monthAgo + &quot;月&quot;)) + (dayAgo &lt; 1 ? &quot;&quot; : (dayAgo + &quot;天&quot;)) + &quot;\\t&quot; + &quot;昨天过生！&quot;; &#125; if (dayAgo == 0) &#123; return (yearAgo &lt; 1 ? &quot;&quot; : (yearAgo + &quot;岁&quot;)) + (monthAgo &lt; 1 ? &quot;&quot; : (monthAgo + &quot;月&quot;)) + (dayAgo &lt; 1 ? &quot;&quot; : (dayAgo + &quot;天&quot;)) + &quot;\\t&quot; + &quot;今天过生！&quot;; &#125; return (yearAgo &lt; 1 ? &quot;&quot; : (yearAgo + &quot;岁&quot;)) + (monthAgo &lt; 1 ? &quot;&quot; : (monthAgo + &quot;月&quot;)) + (dayAgo &lt; 1 ? &quot;&quot; : (dayAgo + &quot;天&quot;))+ &quot;\\t&quot; + &quot;还没过生！&quot;; &#125; //通过天数计算// public static long calTimeAgo(String bornData) &#123;// SimpleDateFormat s = new SimpleDateFormat(&quot;yyy-MM-dd&quot;);//字符串转换成date类型// Date d = null;// //异常处理// try &#123;// d = s.parse(bornData);// &#125; catch (ParseException e) &#123;// e.printStackTrace();// &#125;//// Date now = new Date();//获取当前时间// long nowTime = now.getTime();//将当前date时间转换成毫秒// long bornTime = d.getTime();//将出生日期转换成毫秒// long time = nowTime - bornTime;//当前时间的毫秒减掉出生时间的毫秒就是活了多久的毫秒数// //根据毫秒判断出生与否，出生了就将毫秒时间转换成天数，一秒=一千毫秒，一分钟有60秒，一小时60分，一天24小时// return time / 1000 / 60 / 60 / 24;// &#125;&#125; CardDemo测试类123456789101112131415161718192021222324252627282930313233343536import java.text.ParseException;import java.util.Scanner;/** * @author by LiuKui * @date 2021/3/3. */public class CardIDDemo &#123; public static void main(String[] args) throws ParseException &#123; //用死循环反复测试输入、验证、输出 //注意第一步验证失败不能进入第二步，第二步失败不能进入第三步，所有验证通过才能进行输出。 CardID t = new CardID(); String id = &quot; &quot;; Scanner sc = new Scanner(System.in); while (true) &#123; System.out.print(&quot;请输入需要验证的身份证号：&quot;); id = sc.nextLine(); t.setCardNum(id); if (!t.lengthVerify()) &#123; System.out.println(&quot;长度有错！请重新输入。&quot;); &#125; else if (!t.charVerify()) &#123; System.out.println(&quot;输入非数字字符！请重新输入。&quot;); &#125; else if (!t.checkCodeVerify()) &#123; System.out.println(&quot;最后一位验证码错误！请重新输入。&quot;); &#125; else &#123; t.output(); &#125; &#125; &#125;&#125; 运行结果： 原文章链接:https://blog.csdn.net/qq_45441117/article/details/111336186","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"}]},{"title":"java实验二","date":"2021-03-21T16:23:45.000Z","path":"2021/03/22/java实验二/","text":"※※※※可以参考！但请不要原封不动照搬！※※※※ 实验二：复数类的实现及运算2.2 实验内容及要求：定义一个复数类，并实现以下复数类的方法：构造方法、得到实部、得到虚部、设置实部、设置虚部、复数的加法，减法，乘法，最后，创建对象进行运算。 复数类 Complex 必须满足如下要求: (1) 复数类 Complex 的属性有： realPart : double 型 ，私有属性，代表复数的实数部分 imaginPart : double 型 ，私有属性，代表复数的虚数部分 (2) 复数类 Complex 的构造方法有： Complex( ) : 构造函数，将复数的实部和虚部都置 0。 Complex( double r , double i ) : 构造函数，形参 r 为实部的初值，i 为虚部的初值。 (3) 复数类 Complex 的公有方法有： void setReal(): 设置复数对象的实部值； void setImagin (): 设置复数对象的虚部值； double getReal(): 获得复数对象的实部数值； double getImagin (): 获得复数对象的虚部数值；Complex complexAdd(Complex a) : 将当前复数对象与形参复数对象相加，所得的结果仍是一个复数值，返回给此方法的调用者。 说明：（a+bi）+(c+di)= (a+c)+(b+d)i Complex complexSub(Complex a) : 将当前复数对象与形参复数对象相减，所得的结果仍是一个复数值，返回给此方法的调用者。 Complex complexMulti(Complex a) : 将当前复数对象与形参复数对象相乘，所得的结果仍是一个复数值，返回给此方法的调用者。 说明：（a+bi）*(c+di)=ac+bci+adi+bdi2=(ac-bd)+(bc+ad)i Complex complexDiv(Complex a) : 将当前复数对象与形参复数对象相除，所得的结果仍是一个复数值，返回给此方法的调用者。 说明：复数相除其实采用的是分子分母同时乘以分母的共轭复数，用以将分母的虚部消除掉，除法可调用乘法进行计算更简便。 boolean equals(Complex a) : 将当前复数对象与形参复数对象进行比较，判断是否相等，返回一个布尔值。 String toString( ) : 把当前复数对象的实部、虚部组合成 a+bi 的字符串形式，其中 a 和 b 分别为实部和虚部的数据，注意特殊数值的情况，如实部为 0、虚部为负，等等情况的表现方法。 常见复数的写法有：3+2i，3-2i，4+i，4-i，1，0，-2i，i，-i 等(应当编写一个数组，存入以上 9 个复数，然后循环一次性全部输出，便于检查)。 定义个 ComplexDemo 类：该类是程序的入口，要求能在主方法中创建至少 3 个复数（两个做操作数，通过键盘输入实部和虚部创建，一个做结果，不需实部和虚部），然后调用上述方法进行运算，并打印相应结果进行观察。 关于两个复数方法对于本题是多余的,可以忽略！ Complex类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188/** * @author by LiuKui * @date 2021/3/3. */import java.text.DecimalFormat;import java.util.Objects;//复数类public class Complex &#123; private double realPart, imagePart; //无参构造函数 public Complex() &#123; this.realPart = 0; this.imagePart = 0; &#125; //有构造函数 public Complex(double r, double i) &#123; this.realPart = r; this.imagePart = i; &#125; public double getReal() &#123; return realPart; &#125; public void setReal(double realPart) &#123; this.realPart = realPart; &#125; public double getImage() &#123; return imagePart; &#125; public void setImage(double imagePart) &#123; this.imagePart = imagePart; &#125; //两个复数加法 public Complex AddComplex(Complex a, Complex b) &#123; Complex temp = new Complex(); temp.realPart = a.realPart + b.realPart; temp.imagePart = a.imagePart + b.imagePart; return temp; &#125; //两个复数减法 public Complex SubComplex(Complex a, Complex b) &#123; Complex temp = new Complex(); temp.realPart = a.realPart - b.realPart; temp.imagePart = a.imagePart - b.imagePart; return temp; &#125; //两个复数乘法 public Complex MultiComplex(Complex a, Complex b) &#123; Complex temp = new Complex(); temp.realPart = a.realPart * b.realPart - a.imagePart * b.imagePart; temp.imagePart = a.imagePart - b.imagePart + a.realPart * b.realPart; return temp; &#125; //两个复数除法 public Complex DivComplex(Complex a, Complex b) &#123; Complex temp = new Complex(); temp.realPart = (a.realPart * b.realPart + a.imagePart * b.imagePart) / (Math.pow(b.realPart, 2) + Math.pow(b.imagePart, 2)); temp.imagePart = (a.imagePart * b.realPart + a.realPart * b.imagePart) / (Math.pow(b.realPart, 2) + Math.pow(b.imagePart, 2)); return temp; &#125; //一个复数加法 public Complex ComplexAdd(Complex a) &#123; Complex c3 = new Complex(); c3.realPart = this.realPart + a.realPart; c3.imagePart = this.imagePart + a.imagePart; return c3; &#125; //一个复数减法 public Complex ComplexSub(Complex a) &#123; Complex c3 = new Complex(); c3.realPart = this.realPart - a.realPart; c3.imagePart = this.imagePart - a.imagePart; return c3; &#125; //一个复数乘法 public Complex ComplexMulti(Complex a) &#123; double temp = this.imagePart; Complex c3 = new Complex(); c3.realPart = this.realPart * a.realPart - this.imagePart * a.imagePart; c3.imagePart = temp * a.realPart + this.realPart * a.imagePart; return c3; &#125; //一个复数除法 public Complex ComplexDiv(Complex a) &#123; double temp = this.realPart; Complex c3 = new Complex();// if (!(this.getReal() == 0 &amp;&amp; this.getImage() == 0 &amp;&amp; a.getReal() == 0 &amp;&amp; a.getImage() == 0)) &#123; c3.realPart = (this.realPart * a.realPart + this.imagePart * a.imagePart) / (Math.pow(a.realPart, 2) + Math.pow(a.imagePart, 2)); c3.imagePart = (this.imagePart * a.realPart - temp * a.imagePart) / (Math.pow(a.realPart, 2) + Math.pow(a.imagePart, 2)); return c3;// &#125;// return a; &#125; public Complex multiReal(double d) &#123; Complex c3 = new Complex(); c3.realPart = this.realPart * d; c3.imagePart = this.imagePart * d; return c3; &#125; public double getMod() &#123; return Math.sqrt(Math.pow(this.realPart, 2) + Math.pow(this.imagePart, 2)); &#125; public double getSinArg() &#123; return this.imagePart / this.getMod(); &#125; public double getArg() &#123; double tan = this.imagePart / this.realPart; return Math.atan(tan)/Math.PI*180; &#125; //复数比较是否相同 equals()和hashcode() public boolean equals(Complex o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Complex complex = (Complex) o; return Double.compare(complex.realPart, realPart) == 0 &amp;&amp; Double.compare(complex.imagePart, imagePart) == 0; &#125; @Override public int hashCode() &#123; return Objects.hash(realPart, imagePart); &#125; //打印复数 @Override public String toString() &#123; DecimalFormat df = new DecimalFormat(&quot;#.###&quot;); String rp = df.format(this.realPart); String ip = df.format(this.imagePart); String result = &quot;&quot;; if (this.realPart != 0) &#123; if (this.imagePart == 0) &#123; result = rp; &#125; else if (this.imagePart == 1) &#123; result = rp + &quot;+i&quot;; &#125; else if (this.imagePart == -1) &#123; result = rp + &quot;-i&quot;; &#125; else if (this.imagePart &gt; 0) &#123; result = rp + &quot;+&quot; + ip + &quot;i&quot;; &#125; else &#123; result = rp + ip + &quot;i&quot;; &#125; &#125; else &#123; if (this.imagePart == 0) &#123; result = &quot;0&quot;; &#125; else if (this.imagePart == 1) &#123; result = &quot;i&quot;; &#125; else if (this.imagePart == -1) &#123; result = &quot;-i&quot;; &#125; else if (this.imagePart &lt; 0) &#123; result = ip + &quot;i&quot;; &#125; &#125; return result; &#125;&#125; ComplexDemo测试类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Scanner;public class ComplexDemo &#123; public static void main(String[] args) &#123; Complex[] complexs = new Complex[]&#123;new Complex(3, 2), new Complex(3, -2), new Complex(4, 1), new Complex(4, -1), new Complex(1, 1), new Complex(0, 0), new Complex(0, -2), new Complex(0, 1), new Complex(0, -1)&#125;; for (Complex i : complexs) &#123; System.out.print(i + &quot;,&quot;); &#125; System.out.println(&quot;\\n&quot; + &quot;请输入你想输入的几组数:&quot;); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); for (int i = 1; i &lt; n + 2; i++) &#123; Complex c1 = inComplex(i); Complex c2 = inComplex(++i); System.out.println(&quot;啦啦啦运算******************&quot;); System.out.println(&quot;c1=&quot; + c1 + &quot;\\n&quot; + &quot;c2=&quot; + c2); System.out.println(c1.toString() + &quot;与&quot; + c2.toString() + &quot;是否相同:&quot; + c1.equals(c2)); System.out.println(&quot;-----------------------&quot;); System.out.println(&quot;四则运算结果：&quot;); System.out.println(&quot;加法:\\n&quot; + &quot;c1&quot; + &quot;+&quot; + &quot;c2&quot; + &quot;= &quot; + c1.ComplexAdd(c2)); System.out.println(&quot;减法:\\n&quot; + &quot;c1&quot; + &quot;-&quot; + &quot;c2&quot; + &quot;= &quot; + c1.ComplexSub(c2)); System.out.println(&quot;乘法:\\n&quot; + &quot;c1&quot; + &quot;*&quot; + &quot;c2&quot; + &quot;= &quot; + c1.ComplexMulti(c2)); if (!(c1.getReal() == 0 &amp;&amp; c1.getImage() == 0 &amp;&amp; c2.getReal() == 0 &amp;&amp; c2.getImage() == 0)) &#123; System.out.println(&quot;除法:\\n&quot; + &quot;c1&quot; + &quot;/&quot; + &quot;c2&quot; + &quot;= &quot; + c1.ComplexDiv(c2)); &#125; else &#123; System.out.println(&quot;无法进行除法！&quot;); &#125; &#125; &#125; public static Complex inComplex(int i) &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入第&quot; + i + &quot;个复数:&quot;); double realPart = scanner.nextDouble(); double imagePart = scanner.nextDouble(); return new Complex(realPart, imagePart); &#125;&#125; 运行结果：","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"}]},{"title":"java实验一","date":"2021-03-21T16:16:09.000Z","path":"2021/03/22/java实验一/","text":"※※※※可以参考！但请不要原封不动照搬！※※※※实验一：Java 基础程序设计（1）输入一系列成绩，输出最高分、最低分、平均分，并统计存在多少个并列最高分，要求输入输出格式正确，一重循环解决全部问题。输入：65 87 95 86 72 58 56 75 95 94 78…输出：最高分：95，最低分：56，平均分：72.36，同时存在 2 个并列最高分。 123456789101112131415161718192021222324252627282930public static void question1() &#123; System.out.println(&quot;请输入十个数（以空格分割）:&quot;); Scanner input = new Scanner(System.in); String s = input.nextLine(); String s1[] = s.split(&quot; &quot;); int[] A = new int[11]; for (int i = 0; i &lt; s1.length; i++) &#123; A[i] = Integer.parseInt(s1[i]); &#125; int max = A[0]; int min = A[0]; int sum = 0; int tag = 0; // 记录最高成绩的出现了几次 for (int i : A) &#123; if (i == max) tag++; if (i &gt; max) &#123; max = i; tag = 1; &#125; if (i &lt; min) min = i; sum += i; &#125; System.out.println(&quot;最高分：&quot; + max + &quot;,最低分&quot; + min + &quot;,平均分：&quot; + (double) sum / A.length + &quot;,同时存在&quot; + tag + &quot;个并列最高分.&quot;);&#125; 运行结果： （2）输出 1,000,000 之内的所有素数（即非 1 和自身不能被其他数除尽的数）要求程序简单，程序运行速度较快，行列对齐美观。2 3 5 7 11 13 17 19……1234567891011121314151617181920public static void question2() &#123; int count = 0; for (int i = 2; i &lt;= 1_000_000; i++) &#123; boolean isPrime = true; for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; isPrime = false; break; &#125; &#125; if (isPrime) &#123; if (count == 5) &#123; System.out.println(); count = 0; &#125; System.out.print(i + &quot; &quot;); count++; &#125; &#125;&#125; 运行结果： （3）输出如下图形，行数通过键盘输入的数据确定：123456 1 2 2 1 1 1 2 2 2 2 1 1 1 1 12 2 2 2 2 2 （用死循环反复测试）采用 Scanner 类输入方式：123456789101112131415System.out.print(&quot;请输入金字塔层数：&quot;);Scanner sc=new Scanner(System.in);int num=sc.nextInt();//读入一个整数String s=sc.nextLine();//读入一行字符串采用 JavaIO 流的输入方式：System.out.print(&quot;请输入金字塔层数：&quot;);BufferedReader br=new BufferedReader(new InputStreamReader(System.in));String s=&quot;&quot;;try&#123;s=br.readLine();//读入一行字符串&#125;catch(IOException e)&#123;&#125;int m =Integer.parseInt(s);//把字符串转为整型System.out.println(&quot;将输出&quot;+m+&quot;层的金字塔：&quot;);…… 1234567891011121314151617181920public static void question3() &#123; System.out.print(&quot;请输入金字塔层数：\\n&quot;); int rows = new Scanner(System.in).nextInt(); for (int i = 1; i &lt;= rows; i++) &#123; for (int j = 1; j &lt;= rows - i; j++) &#123; System.out.print(&quot; &quot;); &#125; if (i % 2 != 0) &#123; for (int n = 0; n &lt; i; n++) &#123; System.out.print(1 + &quot; &quot;); &#125; System.out.println(); &#125; else &#123; for (int n = 0; n &lt; i; n++) &#123; System.out.print(2 + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 运行结果：","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"}]},{"title":"hexo主题之hexo-theme-yilia-plus","date":"2019-08-01T03:43:00.000Z","path":"2019/08/01/hexo主题之hexo-theme-yilia-plus/","text":"hexo-theme-yilia-plus 一个简洁优雅的hexo主题 ➡️ https://github.com/JoeyBling/hexo-theme-yilia-plus &#160;&#160;&#160;&#160;此项目是根据hexo-theme-yilia主题做了一些优化和改动，写这个项目的初衷就是深入学习Hexo。使用yilia主题可以快速迁移到yilia-plus 欢迎使用和Star支持，如使用过程中碰到问题，可以提出Issue，我会尽力完善 关于hexo-theme-yilia-plus主题在原基础上做了以下功能升级 手机端头像添加主页跳转链接 集成不蒜子访问量统计功能 网易云音乐插件 页面点击小红心效果 增加了多个SubNav导航图标展示 添加GitHub Ribbons(Fork me) 页脚 Litten自定义(弃用) 添加版权声明 添加百度站长平台主动推送 集成 gitment 评论 ➡️ https://github.com/JoeyBling/yilia-plus-demo 集成码云评论 ➡️ https://gitee.com/zhousiwei/yilia-plus-demo 添加网站成立年份 页面加载进度条 添加苹果图标 标签页标题切换功能 添加字数统计功能 添加文字输入特效 友情链接优化展示 左侧边栏动态图效果、左侧导航栏支持滚动 添加悬停预览图片效果 其他样式轻微调优、社交图标优化 优化配置是否在新窗口打开链接 fix bugs 添加看板娘动态模型插件 如果有小伙伴有新功能的意见或者改进欢迎给我提意见和建议~ 介绍 功能还很少，欢迎各位给我提意见和建议~ 本项目源于：https://github.com/litten/hexo-theme-yilia。向作者表示深深的敬意。 yilia-plus 是为 hexo 2.4+制作的主题。崇尚简约优雅，以及极致的性能。 你可以点击 我的博客 查看效果。 如果想体验手机浏览效果，可以扫一下二维码： 关于主题： 崇尚简约 追求移动端体验 希望把加载速度做到极致（努力中） 让大家把注意力放到内容上。这是本主题设计初衷 主题不支持IE6，7，8。以后也不会 一、外观常规 二、开发者&#160;&#160;&#160;&#160;为了性能和开发工程化考虑，yilia-plus 需要使用webpack进行构建生成。如果您对主题有一些定制化的需求，请参考wiki《yilia-plus源码目录结构及构建须知》 三、开始使用1、安装12cd ./themes/git clone --depth=1 https://github.com/JoeyBling/hexo-theme-yilia-plus.git ./yilia-plus 2、配置修改hexo根目录下的 _config.yml ➡️ theme: yilia-plus 3、更新12cd themes/yilia-plusgit pull 四、配置&#160;&#160;&#160;&#160;主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考yilia-plus博客备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276# Header-菜单menu: 主页: / 技术笔记: https://zhousiwei.gitee.io/ibooks/ 随笔: /tags/随笔/# subNav-子导航subNav: github: &quot;#&quot; gitee: &quot;#&quot; # 码云 jianshu: &quot;#&quot; #简书 #csdn: &quot;#&quot; #rss: &quot;#&quot; #zhihu: &quot;#&quot; #qq: &quot;img/2434387555.jpg&quot; #weixin: &quot;img/weixin_.png&quot; #weibo: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;mailto:zhousiwei0911@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;# 悬停预览图片效果hover_effect: ## `global` 0: Set separately, 1: Enable global 2: Close global ## `global` 0: 分开设置, 1: 全局启用, 2: 全局关闭 global: 2 # SubNav-导航 subNav: true# RSS订阅(关于如何配置启用:https://www.jianshu.com/p/2aaac7a19736)rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 / 设为 /blog/。root: /# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &#x27;展开全文&#x27;# 数学公式mathjax: false# Open link in a new tab | 是否在新窗口打开链接open_in_new: article: true # 文章链接 menu: true # 导航菜单 subNav: true # 子菜单# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &#x27;谢谢你请我吃糖果&#x27;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: /img/alipay.jpg# 微信二维码图片地址weixin: /img/weixin.png# 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &#x27;目录，不存在的…&#x27;# 是否有快速回到顶部的按钮top: true# Miscellaneous# 百度统计baidu_analytics: &#x27;&#x27;google_analytics: &#x27;&#x27;# 网站图标favicon: /favicon.ico# 你的头像urlavatar: /img/head.jpg# 是否开启分享share_jia: true# 评论：1、畅言；2、Disqus；3、Gitment；4、Giteement# 不需要使用某项，直接设置值为false，或注释掉# 具体请参考wiki：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki# 1、畅言changyan_appid: falsechangyan_conf: false# 2、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia-plus的disqus: false# 3、Gitment----基于GitHub的评论系统(关闭请设置gitment_owner为false)# 关于如何集成:https://www.jianshu.com/p/ac7658cc912fgitment_owner: false #你的 GitHub ID# 是否使用官方js(false可以提升访问速度，本地修改过一部分的js，官方js可能会出现服务器不稳定，不太建议使用)gitment_remote: falsegitment_repo: &#x27;&#x27; #存储评论的 repo name(需要在Github创建)gitment_oauth: client_id: &#x27;&#x27; #client ID client_secret: &#x27;&#x27; #client secret# 4、Giteement----【国内用户建议使用这个，相对比较快】# 关于如何集成:https://www.jianshu.com/p/f5c4633524c7# 基于码云的评论系统(https://gitee.com/zhousiwei/giteement)giteement: enable: false # 是否启用码云评论系统 # 是否使用官方js(false可以提升访问速度) remote: false redirect_uri: &#x27;&#x27; # 应用回调地址(请和配置的第三方应用保持一致) # 不能更改(网上开源项目https://github.com/Rob--W/cors-anywhere作者提供的专门用来跨域服务器的配置) oauth_uri: https://cors-anywhere.herokuapp.com/https://gitee.com/oauth/token giteeID: &#x27;&#x27; # 你的码云账号英文名 # 存储评论的 repo name(需要在码云仓库创建公开仓库) repo: &#x27;&#x27; gitment_oauth: client_id: &#x27;&#x27; #client ID client_secret: &#x27;&#x27; #client secret# 访问量统计功能(不蒜子)busuanzi: enable: true site_visit: true # 站点访问量显示 article_visit: true # 文章访问量显示# 网易云音乐插件music: enable: false # 播放器尺寸类型(1：长尺寸、2：短尺寸) type: 2 #id: 1332647902 # 网易云分享的音乐ID(更换音乐请更改此配置项) autoPlay: true # 是否开启自动播放 # 提示文本(关闭请设置为false) text: &#x27;这似乎是首纯音乐，请尽情的欣赏它吧！&#x27;# 页面点击小红心clickLove: # (关闭请设置为false) enable: true# GitHub Ribbons(https://github.blog/2008-12-19-github-ribbons/)github: # (关闭请设置为false) url: https://github.com/JoeyBling/hexo-theme-yilia-plus# 页脚 Litten(此配置项已弃用)# 帮助我们让更多人可以更方便使用Hexo，请尽量不要修改此主题配置pageFooter: litten: GitHub:&lt;a href=&quot;https://github.com/JoeyBling/hexo-theme-yilia-plus&quot; target=&quot;_blank&quot;&gt;hexo-theme-yilia-plus&lt;/a&gt;# 开启百度站长平台主动推送(https://ziyuan.baidu.com/linksubmit/index)baidu_push: false# 版权声明# 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明copyright_type: 2# 网站成立年份(默认为 2018，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)since: 2018# Progress Bar | 页面加载进度条# Demo: http://github.hubspot.com/pace/docs/welcome/# type: barber-shop|big-counter|bounce|center-atom|center-circle|# center-radar|center-simple|corner-indicator|flash|flat-top|# loading-bar|mac-osx|minimal# color: black|blue|green|orange|pink|purple|red|silver|white|yellow|progressBar: enable: false type: &#x27;minimal&#x27; # Keep Quotes | 保留引号避免出错(某些type会导致样式重叠排版错误) color: blue# Apple Touch icon 苹果图标(关闭请设置为false)apple_touch_icon: &#x27;/apple-touch-icon-180x180.png&#x27;# Tab Title Change | 标签页标题切换tab_title_change: enable: true left_tab_title: &#x27;(つェ⊂) 我藏好了哦~ &#x27; return_tab_title: &#x27;(*´∇｀*) 被你发现啦~ &#x27;# https://github.com/willin/hexo-wordcount# 是否开启字数统计(关闭请设置enable为false)# 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计word_count: enable: true # 只在文章详情显示(不在首页显示) only_article_visit: true# 文字输入特效# https://github.com/disjukr/activate-power-modeactivate_power_mode: enable: true # 使输入模式丰富多彩 colorful: true # 是否开启摇动 shake: false# 看板娘动态模型插件## https://github.com/JoeyBling/live2d-widget.jslive2d: # (关闭请设置为false) enable: false # 模型名称(取值请参考：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki/live2d%E6%A8%A1%E5%9E%8B%E5%8C%85%E5%B1%95%E7%A4%BA) model: hibiki display: position: right # 显示位置：left/right(default: &#x27;right&#x27;) width: 145 # 模型的长度(default: 150) height: 315 # 模型的高度(default: 300) hOffset: 50 # 水平偏移(default: 0) #vOffset: -20 # 垂直偏移(default: -20) mobile: show: false # 是否在移动设备上显示(default: true) scale: 0.6 # 移动设备上的缩放(default: 0.5) react: opacity: 0.8 # 模型透明度(default: 0.7)# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 # header: &#x27;#D3D1DC&#x27; header: &#x27;#4d4d4d&#x27; gif: # 是否启用左侧边栏动态图效果 enable: false # 自定义背景图路径(默认可以不设置，提供默认背景图) # path: /img/biubiubiu.gif # 右滑板块背景 slider: &#x27;linear-gradient(200deg,#a0cfe4,#e8c37e)&#x27;# slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &#x27;所有文章&#x27; friends: &#x27;友链&#x27; aboutme: &#x27;关于我&#x27;# 友情链接friends: 技术笔记: #网站名称 #网站地址 url: https://zhousiwei.gitee.io/ibooks/ #网站图片(可忽略不写) img: https://zhousiwei.gitee.io/ibooks/favicon.ico #网站简介(可忽略不写) description: 记录工作和学习过程中的笔记：Java、前端开发、Hexo博客、聚合支付、Linux笔记、ElasticSearch、ELK日志分析 GitHub: url: https://github.com/JoeyBling 码云: url: https://gitee.com/zhousiwei 简书: url: https://www.jianshu.com/u/02cbf31a043a CSDN: url: https://blog.csdn.net/qq_30930805# 关于我aboutme: 主要涉及技术：&lt;br&gt;Java后端开发、聚合支付、&lt;br&gt;公众号开发、开源爱好者、Linux&lt;br&gt;&lt;br&gt;联系QQ:2434387555&lt;br&gt;&lt;br&gt;很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家 Hexo博客优化 Hexo博客集成码云评论系统 Hexo博客集成Gitment评论 Hexo博客配置RSS插件 Hexo博客使用gulp压缩静态资源 新增Hexo博客文章置顶功能 Hexo博客添加helper-live2d动态模型插件 Hexo博客添加访问量统计 Hexo博客yilia主题添加背景音乐 （网易云音乐） 使用Hexo+GitHub搭建免费个人博客","link":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luikui.xyz/tags/Hexo/"}]},{"title":"关于npm install失败的解决方法","date":"2019-07-30T01:33:15.000Z","path":"2019/07/30/关于npm install失败的解决方法/","text":"可以尝试以下解决方案 1.授权执行1sudo npm install 2.运行高权限用户1sudo npm install --unsafe-perm 3.安装某个模块1sudo npm i 模块名 --unsafe-perms 4.清除代理1npm config set proxy false 5.清除缓存1npm cache clean","link":"","tags":[{"name":"日记本","slug":"日记本","permalink":"https://luikui.xyz/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"Hexo编译文档时JS或HTML混乱解决方案","date":"2019-07-26T03:26:51.000Z","path":"2019/07/26/Hexo编译文档时JS或HTML混乱解决方案/","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 之前为在 GitHub 博客上写自己的 html 网页，在 hexo 根目录下的 source 文件夹中放了自己的 js 文件，每次 hexo g 后，pubic 文件夹中的 js 文件就混乱了，与自己实际 js 不一致。 解决方案(跳过 hexo 渲染) Hexo 3.0 以上支持修改 Hexo 主目录下的 _config.yml 配置文件中的 skip_render 参数。 1234567891011skip_render: &quot;test.html&quot; # source 文件夹下指定文件skip_render: test/* # 单个文件夹下全部文件skip_render: test/*.md # 单个文件夹下指定类型文件skip_render: test/** # 单个文件夹下全部文件及子文件skip_render: # 多个文件夹以及其他情况 - test/* - test/*.html 博主自己的配置如下 1234567891011121314# 跳过 hexo 渲染skip_render: - anires/** - assets/** - gitment/** - baidu_sitepush/** - canvas_nest/** - docs/** - &#x27;baidu_verify_QzGNSJ7F59.html&#x27; - &#x27;*.html&#x27; - &#x27;*.js&#x27; - README.md - &#x27;*.sh&#x27; - &#x27;*.txt&#x27; 注：若修改配置后不见效果，先执行 hexo clean 后再执行 hexo g 重新编译","link":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luikui.xyz/tags/Hexo/"}]},{"title":"Hexo博客集成码云评论系统","date":"2019-07-25T02:39:00.000Z","path":"2019/07/25/Hexo博客集成码云评论系统/","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 简介 giteement系统是基于gitment的源码开发和扩展的 ➡️ https://gitee.com/zhousiwei/giteementgiteement还在继续维护优化中…欢迎小伙伴们加入一起维护 目前实现以下功能： 基于码云的issues来进行评论的,所以需要有码云账号。 实现了类似码云issues的回复功能，评论开头用@符号选择你要回复的人，回复完毕，如果你要回复的人登录码云，会有消息提示。 效果展示 ➡️ https://zhousiwei.gitee.io/ 1、配置第三方应用&#160;&#160;&#160;&#160;使用码云的issues作为评论系统，就要使用码云来登录评论，所以需要在码云上配置第三方应用。 注册一个新的第三方应用 ➡️ https://gitee.com/oauth/applications/new 应用名称(根据实际来填写) 应用描述(根据实际来填写) 应用主页(应用程序主页的完整URL) 应用回调地址(一般是博客的域名) 权限请选择issues、notes 2、配置hexo-theme-yilia-plus主题注册完成后得到Client ID和Client Secret 修改hexo-theme-yilia-plus主题的配置文件_config.yml12345678910111213giteement: enable: true # 是否启用码云评论系统 # 是否使用官方js(false可以提升访问速度) remote: false redirect_uri: https://zhousiwei.gitee.io/yilia-plus-demo # 应用回调地址(请和配置的第三方应用保持一致) # 不能更改(网上开源项目https://github.com/Rob--W/cors-anywhere作者提供的专门用来跨域服务器的配置) oauth_uri: https://cors-anywhere.herokuapp.com/https://gitee.com/oauth/token giteeID: zhousiwei # 你的码云账号英文名 # 存储评论的 repo repo: yilia-plus-demo gitment_oauth: client_id: &#x27;*********&#x27; #client ID client_secret: &#x27;*********&#x27; #client secret 3、重新编译运行即可查看效果1hexo s -g 针对不同文章的date属性生成id，只要保证每篇文章有date属性并且不重复即可 hexo-theme-yilia-plus配置Demo ➡️ https://gitee.com/zhousiwei/yilia-plus-demo 4、待解决问题 giteement的UI是直接使用gitment的UI，不是很好看，后期准备优化。 新增文章的时候需要登录自己的gitee账号，点击评论初始化按钮。(后面考虑实现自动初始化 Gitment 评论脚本) 效果图1、整体UI 2、@回复功能 其他主题例子1、主题landscape中使用修改themes/landscape/layout/index.ejs文件 修改themes/landscape/layout/_partial/article.ejs文件 增加themes/landscape/layout/_partial/comment.ejs1234567891011121314151617181920212223242526&lt;% if (!index &amp;&amp; post.comments &amp;&amp; theme.giteement &amp;&amp; theme.giteement.enable)&#123; %&gt; &lt;div id=&quot;giteement-ctn&quot;&gt;&lt;/div&gt; &lt;% if (theme.giteement &amp;&amp; theme.giteement.remote)&#123; %&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://giteement.oss-cn-beijing.aliyuncs.com/wd-discuss.css&quot;&gt; --&gt; &lt;!-- &lt;script src=&quot;https://giteement.oss-cn-beijing.aliyuncs.com/discuss_hexo.js&quot;&gt;&lt;/script&gt; --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://giteement.oss-cn-beijing.aliyuncs.com/default.css&quot;&gt; &lt;script src=&quot;https://giteement.oss-cn-beijing.aliyuncs.com/giteement.browser.js&quot;&gt;&lt;/script&gt; &lt;% &#125; else &#123; %&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=config.root%&gt;assets/default.css&quot;&gt; &lt;script src=&quot;&lt;%=config.root%&gt;assets/giteement.browser.js&quot;&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;script&gt; var giteement = new Giteement(&#123; id: &#x27;&lt;%=page.date.format(&#x27;YYYYMMDDHHmmss&#x27;)%&gt;&#x27;, owner: &#x27;&lt;%=theme.giteement.giteeID%&gt;&#x27;, repo: &#x27;&lt;%=theme.giteement.repo%&gt;&#x27;, backcall_uri: &#x27;&lt;%=theme.giteement.redirect_uri%&gt;&#x27;, oauth_uri: &#x27;&lt;%=theme.giteement.oauth_uri%&gt;&#x27;, oauth: &#123; client_id: &#x27;&lt;%=theme.giteement.gitment_oauth.client_id%&gt;&#x27;, client_secret: &#x27;&lt;%=theme.giteement.gitment_oauth.client_secret%&gt;&#x27; &#125;, &#125;) giteement.render(&#x27;giteement-ctn&#x27;) &lt;/script&gt;&lt;% &#125; %&gt; 2、主题next中使用修改themes/next/layout/index.swig文件 修改themes/next/layout/_partials/comments.swig文件 把theme.giteement.ClientID和theme.giteement.ClientSecret改为theme.giteement.gitment_oauth.client_id和theme.giteement.gitment_oauth.client_secret 转载自原作者eillott的文章，进行修改了一部分，并且集成了**hexo-theme-yilia-plus**主题","link":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luikui.xyz/tags/Hexo/"}]},{"title":"Hexo博客集成Gitment评论","date":"2019-07-24T08:52:00.000Z","path":"2019/07/24/Hexo博客集成Gitment评论/","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 Gitment 是一位作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 1、注册 OAuth Application 注册一个新的 OAuth Application ➡️ OAuth Application Application name 应用名称(根据实际来填写) Homepage URL 主页网址(应用程序主页的完整URL) Application description 应用说明(应用描述) Authorization callback URL 授权回调URL(一般是博客的域名) 2、配置hexo-theme-yilia-plus主题注册完成后得到Client ID和Client Secret 修改hexo-theme-yilia-plus主题的配置文件_config.yml123456gitment_owner: JoeyBling #你的 GitHub IDgitment_remote: false # 是否使用官方js(false可以提升访问速度)gitment_repo: &#x27;yilia-plus-demo&#x27; #存储评论的 repogitment_oauth: client_id: &#x27;*********&#x27; #client ID client_secret: &#x27;*********&#x27; #client secret 3、重新编译运行即可查看效果1hexo s -g hexo-theme-yilia-plus配置Demo ➡️ https://joeybling.github.io/yilia-plus-demo","link":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luikui.xyz/tags/Hexo/"}]},{"title":"Hexo博客配置RSS插件","date":"2019-07-23T07:49:00.000Z","path":"2019/07/23/Hexo博客配置RSS插件/","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 1、安装rss插件 在站点根目录下安装 1npm install hexo-generator-feed 2、配置_config.yml文件，启用插件12345678# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 3、在hexo-theme-yilia-plus主题添加RSS订阅配置(可以跳过此步骤) theme-yilia-plus 12# RSS订阅rss: /atom.xml 4、生成RSS订阅文件1hexo g","link":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luikui.xyz/tags/Hexo/"}]},{"title":"gulp-babel 取消严格模式(\"use strict\")","date":"2019-07-23T01:38:00.000Z","path":"2019/07/23/gulp-babel取消严格模式use strict/","text":"插件地址 ➡️ https://github.com/genify/babel-plugin-transform-remove-strict-mode 1、安装1npm install babel-plugin-transform-remove-strict-mode 2、使用 添加内容到.babelrc文件 123&#123; &quot;plugins&quot;: [&quot;transform-remove-strict-mode&quot;]&#125; 重新执行打包命令即可","link":"","tags":[{"name":"日记本","slug":"日记本","permalink":"https://luikui.xyz/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"Hexo博客使用gulp压缩静态资源","date":"2019-07-22T08:35:00.000Z","path":"2019/07/22/Hexo博客使用gulp压缩静态资源/","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 1、全局安装gulp123npm install gulp -g# 查看版本gulp -v 2、安装gulp插件 在站点根目录下安装 12345678910111213npm install gulp --savenpm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save# 解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript# 解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题npm install babel-core@6.26.3 --savenpm install gulp-babel@7.0.1 --savenpm install babel-preset-es2015@6.24.1 --save# gulp-babel 取消严格模式方法(&quot;use strict&quot;)npm install babel-plugin-transform-remove-strict-mode --save 问题：如果安装gulp-imagemin错误请执行以下语句sudo npm i gulp-imagemin --unsafe-perms 3、创建gulpfile.js文件 在 Hexo 站点下新建gulpfile.js文件，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var gulp = require(&#x27;gulp&#x27;);var minifycss = require(&#x27;gulp-minify-css&#x27;);var uglify = require(&#x27;gulp-uglify&#x27;);var htmlmin = require(&#x27;gulp-htmlmin&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);var imagemin = require(&#x27;gulp-imagemin&#x27;);var babel = require(&#x27;gulp-babel&#x27;);// 压缩css文件gulp.task(&#x27;minify-css&#x27;, function (done) &#123; return gulp.src(&#x27;./public/**/*.css&#x27;) .pipe(minifycss()) .pipe(gulp.dest(&#x27;./public&#x27;)); done();&#125;);// 压缩html文件gulp.task(&#x27;minify-html&#x27;, function (done) &#123; return gulp.src(&#x27;./public/**/*.html&#x27;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;)); done();&#125;);// 压缩js文件gulp.task(&#x27;minify-js&#x27;, function (done) &#123; return gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]) .pipe(babel(&#123; //将ES6代码转译为可执行的JS代码 presets: [&#x27;es2015&#x27;] // es5检查机制 &#125;)) .pipe(uglify()) .pipe(gulp.dest(&#x27;./public&#x27;)); done();&#125;);// 压缩 public/images 目录内图片(Version&lt;3)// gulp.task(&#x27;minify-images&#x27;, function () &#123;// gulp.src(&#x27;./public/images/**/*.*&#x27;)// .pipe(imagemin(&#123;// optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）// progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片// interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染// multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化// &#125;))// .pipe(gulp.dest(&#x27;./public/images&#x27;));// &#125;);// 压缩 public/images 目录内图片(Version&gt;3)gulp.task(&#x27;minify-images&#x27;, function (done) &#123; gulp.src(&#x27;./public/images/**/*.*&#x27;) .pipe(imagemin([ imagemin.gifsicle(&#123;interlaced: true&#125;), imagemin.jpegtran(&#123;progressive: true&#125;), imagemin.optipng(&#123;optimizationLevel: 5&#125;), imagemin.svgo(&#123; plugins: [ &#123;removeViewBox: true&#125;, &#123;cleanupIDs: false&#125; ] &#125;) ])) .pipe(gulp.dest(&#x27;./public/images&#x27;)); done();&#125;);//4.0以前的写法 //gulp.task(&#x27;default&#x27;, [// &#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;, &#x27;minify-images&#x27;//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task(&#x27;default&#x27;, gulp.series(gulp.parallel(&#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;, &#x27;minify-images&#x27;)), function () &#123; console.log(&quot;----------gulp Finished----------&quot;); // Do something after a, b, and c are finished.&#125;); 4、创建.babelrc文件 在 Hexo 站点下新建.babelrc文件，文件内容如下： 1234&#123; &#x27;presets&#x27;: [&#x27;es2015&#x27;], &quot;plugins&quot;: [&quot;transform-remove-strict-mode&quot;]&#125; 5、静态资源压缩 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩 12hexo ggulp","link":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://luikui.xyz/tags/Hexo/"}]},{"title":"Git分支的创建、删除、切换","date":"2019-07-01T02:06:00.000Z","path":"2019/07/01/Git分支的创建、删除、切换/","text":"1、本地创建新分支并切换到新分支1# git checkout -b 分支名 2、提交分支到远程仓库1# git push origin 分支名 3、切换分支1# git checkout 分支名 4、删除远程分支1# git push origin --delete 分支名 5、删除本地分支1# git branch -D 分支名 Tips：其他分支命令 查看当前分支 git branch 查看所属分支 git branch -a","link":"","tags":[{"name":"日记本","slug":"日记本","permalink":"https://luikui.xyz/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"Git彻底删除历史提交记录的方法","date":"2019-06-05T02:22:00.000Z","path":"2019/06/05/Git彻底删除历史提交记录的方法/","text":"1、查看Git提交记录1# git log 2、找到需要回滚到的提交点，复制它的hash值 1# git reset --hard 你复制的hash值 3、将当前指向的head推到git1# git push --force","link":"","tags":[{"name":"日记本","slug":"日记本","permalink":"https://luikui.xyz/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"玩转MySQL优化命令","date":"2019-05-06T10:05:00.000Z","path":"2019/05/06/玩转MySQL优化命令/","text":"1、MySQL更改为只能本地登录123# use mysql;# select user,host,Password from user where user=&#x27;root&#x27;;# delete from user where user=&#x27;root&#x27; and host=&#x27;%&#x27;; 2、MySQL授予外网登陆权限grant all privileges on *.* to 授予外网登陆的用户名@&#39;%&#39; identified by &#39;密码&#39; WITH GRANT OPTION; 12# grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27; WITH GRANT OPTION;# flush privileges; 3、更改MySQL的存储目录","link":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://luikui.xyz/tags/MySQL/"}]},{"title":"Hexo博客添加helper-live2d动态模型插件","date":"2019-05-05T08:35:00.000Z","path":"2019/05/05/Hexo博客添加helper-live2d动态模型插件/","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 插件的github地址hexo-helper-live2d live2d模型仓库 必须有Node环境 ➡️ Linux下安装node和npm 1、安装模块&#160;&#160;&#160;&#160;在hexo根目录执行命令 1# npm install --save hexo-helper-live2d 2、下载模型&#160;&#160;&#160;&#160;作者各种模型包展示 ➡️ hexo live2d插件 2.0 ! live2d模型仓库 live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 使用npm install &#123;packagename&#125;安装模型 12---笔者使用的模型# npm install live2d-widget-model-hibiki 3、详细配置在Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.参阅 live2d-widget.js API 博主配置文件示例12345678910111213141516171819202122232425262728293031# Live2D## https://github.com/EYHN/hexo-helper-live2d## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: enable: true #enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-hibiki # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right width: 145 height: 315 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8 4、作者寄语 Everything is ok. But you have to do by yourself.","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"https://luikui.xyz/tags/Hexo/"}]},{"title":"vi/vim 粘贴内容时,保留原文件内容格式","date":"2019-05-05T07:33:00.000Z","path":"2019/05/05/vi或vim粘贴内容时,保留原文件内容格式/","text":"在vi/vim普通模式下执行:set paste命令，再按 i 插入就会保留原文件格式 :set paste 打开粘贴命令 :set nopaste 关闭命令 :h paste 帮助","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"}]},{"title":"新增Hexo博客文章置顶功能","date":"2019-02-25T03:40:00.000Z","path":"2019/02/25/新增Hexo博客文章置顶功能/","text":"修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js需要添加的代码： 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); 以下是最终的generator.js内容： 12345678910111213141516171819202122232425262728293031323334&#x27;use strict&#x27;;var pagination = require(&#x27;hexo-pagination&#x27;);module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || &#x27;page&#x27;; var path = config.index_generator.path || &#x27;&#x27;; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: [&#x27;index&#x27;, &#x27;archive&#x27;], format: paginationDir + &#x27;/%d/&#x27;, data: &#123; __index: true &#125; &#125;);&#125;; 如何使用：在需要置顶的文章添加top属性即可，排序从小到大 博客效果： Tips:常用hexo命令123# hexo n == hexo new# hexo g == 生成# hexo s == 启动服务","link":"","tags":[{"name":"日记本","slug":"日记本","permalink":"https://luikui.xyz/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"IDEA设置后端代码开发规范","date":"2019-01-23T02:33:00.000Z","path":"2019/01/23/IDEA设置后端代码开发规范/","text":"1、IDEA 配置svn提交svn报错： 1.1、下载：https://www.visualsvn.com/downloads/ 1.2、修改IDEA配置指向的路径2、IDEA 设置 Tab 键为 4 个空格Scheme 选择 Project ,在下面把取消勾选 Use tab character 3、IDEA 设置编码格式为 UTF-8 4、IDEA 设置换行符为 Unix 编码格式 5、IDEA 设置类注释模板 1234/** * * @author Created by 思伟 on $&#123;DATE&#125; */","link":"","tags":[{"name":"日记本","slug":"日记本","permalink":"https://luikui.xyz/tags/%E6%97%A5%E8%AE%B0%E6%9C%AC/"}]},{"title":"SpringBoot 2.0 更新记录","date":"2018-08-21T02:43:00.000Z","path":"2018/08/21/SpringBoot 2.0 更新记录/","text":"1、Spring Boot 2.0 要求Java 版本必须8以上2、配置属性的重定位 Old property New property server.context-path server.servlet.context-path server.context-parameters.* server.servlet.context-parameters.* server.jsp.class-name server.servlet.jsp.class-name server.jsp.init-parameters.* server.servlet.jsp.init-parameters.* server.jsp.registered server.servlet.jsp.registered server.servlet-path server.servlet.path","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"}]},{"title":"Linux下更改MySQL的存储目录","date":"2018-08-06T09:06:00.000Z","path":"2018/08/06/Linux下更改MySQL的存储目录/","text":"重要步骤：一定要先停止Mysql1# service mysqld stop 1、创建目标文件夹12# mkdir -p /data/mysql# chown -R mysql.mysql /data/mysql/ 2、迁移命令1# mysql_install_db --user=mysql --basedir=/usr --datadir=/data/mysql 3、为避免麻烦，删掉原文件夹/var/lib/mysql1# rm -rf /var/lib/mysql/* 4、修改/etc/my.cnf配置文件12[mysqld]datadir=/data/mysql 5、启动mysql12# chkconfig mysqld on# service mysqld restart","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"}]},{"title":"SpringBoot设置默认首页","date":"2018-04-26T07:49:00.000Z","path":"2018/04/26/SpringBoot设置默认首页/","text":"1234567891011@Configurationpublic class DefaultView extends WebMvcConfigurerAdapter&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; super.addViewControllers(registry); //主页 registry.addViewController(&quot;/&quot;).setViewName(&quot;forward:/index&quot;); &#125; &#125;","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://luikui.xyz/tags/Java/"}]},{"title":"解决MariaDB中文乱码","date":"2018-04-26T07:46:00.000Z","path":"2018/04/26/解决MariaDB中文乱码/","text":"1、检查自己数据库编码12# mysql -uroot -proot# show VARIABLES like &#x27;char%&#x27;; 2、更改Client和Server编码都是UTF-81# vim /etc/my.cnf.d/server.cnf 在server.cnf中[mysqld]标签下添加代码 12init-connect=&#x27;SET NAMES utf8&#x27;character-set-server = utf8 重启MariaDB即可123# systemctl restart mariadb--- 如果已经添加为服务# service mysqld restart","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"}]},{"title":"Linux或Win下安装node和npm","date":"2018-04-20T07:31:00.000Z","path":"2018/04/20/Linux或Win下安装node和npm/","text":"一、离线安装Node 官网下载链接：https://nodejs.org/zh-cn/download/node和npm对应关系：https://nodejs.org/zh-cn/download/releases/ 解压目录 1234# cd /usr/local# yum install -y xz# xz -d node-v8.11.1-linux-x64.tar.xz# tar -xf node-v8.11.1-linux-x64.tar 这里想要全局使用npm 和 node,就需要做相关软链，如下！ 123# cd /usr/local/bin# ln -s /usr/local/src/node-v8.10.0-linux-x64/bin/npm# ln -s /usr/local/src/node-v8.10.0-linux-x64/bin/node 然后即可在任意位置执行 node -v npm -v 查看相应的版本，则安装完成！ 二、yum安装node和npm(Linux快速安装)12# yum install epel-release -y# yum install nodejs -y 三、使用淘宝镜像站(建议跳过此步骤，不建议使用)1234# npm config get registry // https://registry.npmjs.org/# npm config set registry https://registry.npm.taobao.org---- 验证是否配置成功# npm config get registry 四、指定全局安装路径和缓存路径(看自己选择是否使用) 设置全局模块的安装路径到 node_global 文件夹，设置缓存到 node_cache 文件夹 12345# npm config set prefix D:\\nodejs\\node_global# npm config set cache D:\\nodejs\\node_cache---- 验证是否配置成功# npm config get cache# npm ls -g 五、安装 cnpm(看自己选择是否使用)12# npm install cnpm -g --registry=https://registry.npm.taobao.org# cnpm -v Tips: npm默认的全局目录可执行命令查看1# npm config ls","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"}]},{"title":"Linux配置SSH Key到GitHub","date":"2018-04-17T06:48:40.000Z","path":"2018/04/17/Linux配置SSH-Key到GitHub/","text":"1、生成SSH Key首先检查下本机是否已经安装了SSH，在终端输入ssh即可： 如果没有安装进行yum安装 1# yum -y install openssh-clients 接下来就是生成ssh key了，输入ssh-keygen -t rsa，然后连续按回车键三次（注意：千万不要输入密码！）。 id_rsa.pub为公钥，id_rsa为私钥，它们都是隐藏文件。那么如何查看它们的内容呢？只需要继续执行以下两条命令即可。 12# cd .ssh/# cat id_rsa.pub 2、添加SSH Key到GitHub上 接着执行下面操作： 点击New SSH Key按钮后进行Key的填写操作，完成SSH Key的添加。如下图： 添加SSH Key成功之后，继续输入命令进行测试。 1# ssh -T git@github.com 出现上图结果则说明添加SSH Key成功。","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"}]},{"title":"Linux下安装Git","date":"2018-04-17T05:41:00.000Z","path":"2018/04/17/Linux下安装Git/","text":"1、使用yum安装12# yum -y install git# yum remove git 2、源代码安装 1234567891011121314151617---安装依赖的包# yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker zlib# cd /usr/local----下载git源码# wget https://github.com/git/git/archive/v2.21.0.tar.gz----解压git源码# tar -zxvf v2.21.0.tar.gz# cd git-2.21.0/# mkdir /usr/local/git----编译安装到指定目录# make prefix=/usr/local/git all# sudo make prefix=/usr/local/git install# vim /etc/profile----添加在文件的最后一行export PATH=/usr/local/git/bin:$PATH# source /etc/profile# git --version 3、FAQ1、 如果解压时出现报错，建议手动下载git源码包然后上传到服务器1234gzip: stdin: unexpected end of filetar: Unexpected EOF in archivetar: Unexpected EOF in archivetar: Error is not recoverable: exiting now","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luikui.xyz/tags/Linux/"}]}]